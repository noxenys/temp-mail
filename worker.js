var __defProp = Object.defineProperty; var __getOwnPropNames = Object.getOwnPropertyNames; var __name = (target, value) => __defProp(target, "name", { value, configurable: true }); var __esm = (fn, res) => function __init() { return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res; }; var __export = (target, all) => { for (var name in all) __defProp(target, name, { get: all[name], enumerable: true }); }; var cacheHelper_exports = {}; __export(cacheHelper_exports, { clearAllCache: () => clearAllCache, clearExpiredCache: () => clearExpiredCache, getCachedMailboxId: () => getCachedMailboxId, getCachedSystemStat: () => getCachedSystemStat, getCachedTableStructure: () => getCachedTableStructure, getCachedUserQuota: () => getCachedUserQuota, hasColumn: () => hasColumn, invalidateMailboxCache: () => invalidateMailboxCache, invalidateSystemStatCache: () => invalidateSystemStatCache, invalidateUserQuotaCache: () => invalidateUserQuotaCache, updateMailboxIdCache: () => updateMailboxIdCache }); async function getCachedTableStructure(db, tableName) { const cacheKey = tableName; const cached = CACHE.tableStructures.get(cacheKey); if (cached && Date.now() - cached.timestamp < CACHE_TTL.tableStructure) { return cached.data; } try { const res = await db.prepare(`PRAGMA table_info(${tableName})`).all(); const cols = (res?.results || []).map((r) => ({ name: r.name || r?.["name"], type: r.type || r?.["type"], notnull: r.notnull ? 1 : 0, dflt_value: r.dflt_value })); CACHE.tableStructures.set(cacheKey, { data: cols, timestamp: Date.now() }); return cols; } catch (e) { console.error("\u83B7\u53D6\u8868\u7ED3\u6784\u5931\u8D25:", e); return []; } } async function hasColumn(db, tableName, columnName) { const cols = await getCachedTableStructure(db, tableName); return cols.some((c) => c.name === columnName); } async function getCachedMailboxId(db, address) { const normalized = String(address || "").trim().toLowerCase(); if (!normalized) return null; const cached = CACHE.mailboxIds.get(normalized); if (cached && Date.now() - cached.timestamp < CACHE_TTL.mailboxId) { return cached.id; } const res = await db.prepare("SELECT id FROM mailboxes WHERE address = ?").bind(normalized).all(); const id = res.results && res.results.length ? res.results[0].id : null; CACHE.mailboxIds.set(normalized, { id, timestamp: Date.now() }); return id; } function updateMailboxIdCache(address, id) { const normalized = String(address || "").trim().toLowerCase(); if (!normalized || !id) return; CACHE.mailboxIds.set(normalized, { id, timestamp: Date.now() }); } function invalidateMailboxCache(address) { const normalized = String(address || "").trim().toLowerCase(); CACHE.mailboxIds.delete(normalized); } async function getCachedUserQuota(db, userId) { const cached = CACHE.userQuotas.get(userId); if (cached && Date.now() - cached.timestamp < CACHE_TTL.userQuota) { return cached.data; } const ures = await db.prepare("SELECT mailbox_limit FROM users WHERE id = ?").bind(userId).all(); const limit = ures?.results?.[0]?.mailbox_limit ?? 10; const cres = await db.prepare("SELECT COUNT(1) AS c FROM user_mailboxes WHERE user_id = ?").bind(userId).all(); const used = cres?.results?.[0]?.c || 0; const data = { used, limit }; CACHE.userQuotas.set(userId, { data, timestamp: Date.now() }); return data; } function invalidateUserQuotaCache(userId) { CACHE.userQuotas.delete(userId); } async function getCachedSystemStat(db, statKey, queryFn) { const cached = CACHE.systemStats.get(statKey); if (cached && Date.now() - cached.timestamp < CACHE_TTL.systemStats) { return cached.value; } const value = await queryFn(db); CACHE.systemStats.set(statKey, { value, timestamp: Date.now() }); return value; } function invalidateSystemStatCache(statKey = null) { if (statKey) { CACHE.systemStats.delete(statKey); } else { CACHE.systemStats.clear(); } } function clearExpiredCache() { const now = Date.now(); if (now - CACHE.lastClearTime < CACHE_TTL.clearInterval) { return; } CACHE.lastClearTime = now; for (const [key, value] of CACHE.mailboxIds.entries()) { if (now - value.timestamp > CACHE_TTL.mailboxId) { CACHE.mailboxIds.delete(key); } } for (const [key, value] of CACHE.userQuotas.entries()) { if (now - value.timestamp > CACHE_TTL.userQuota) { CACHE.userQuotas.delete(key); } } for (const [key, value] of CACHE.systemStats.entries()) { if (now - value.timestamp > CACHE_TTL.systemStats) { CACHE.systemStats.delete(key); } } } function clearAllCache() { CACHE.tableStructures.clear(); CACHE.mailboxIds.clear(); CACHE.userQuotas.clear(); CACHE.systemStats.clear(); CACHE.lastClearTime = Date.now(); } var CACHE, CACHE_TTL; var init_cacheHelper = __esm({ "src/cacheHelper.js"() { CACHE = { tableStructures: new Map(), mailboxIds: new Map(), userQuotas: new Map(), systemStats: new Map(), lastClearTime: Date.now() }; CACHE_TTL = { tableStructure: 60 * 60 * 1e3, mailboxId: 10 * 60 * 1e3, userQuota: 5 * 60 * 1e3, systemStats: 10 * 60 * 1e3, clearInterval: 30 * 60 * 1e3 }; __name(getCachedTableStructure, "getCachedTableStructure"); __name(hasColumn, "hasColumn"); __name(getCachedMailboxId, "getCachedMailboxId"); __name(updateMailboxIdCache, "updateMailboxIdCache"); __name(invalidateMailboxCache, "invalidateMailboxCache"); __name(getCachedUserQuota, "getCachedUserQuota"); __name(invalidateUserQuotaCache, "invalidateUserQuotaCache"); __name(getCachedSystemStat, "getCachedSystemStat"); __name(invalidateSystemStatCache, "invalidateSystemStatCache"); __name(clearExpiredCache, "clearExpiredCache"); __name(clearAllCache, "clearAllCache"); } }); var authentication_exports = {}; __export(authentication_exports, { COOKIE_NAME: () => COOKIE_NAME, buildSessionCookie: () => buildSessionCookie, createJwt: () => createJwt, hashPassword: () => hashPassword, verifyJwt: () => verifyJwt, verifyMailboxLogin: () => verifyMailboxLogin, verifyPassword: () => verifyPassword }); async function createJwt(secret, extraPayload = {}) { const header = { alg: "HS256", typ: "JWT" }; const payload = { exp: Math.floor(Date.now() / 1e3) + 24 * 60 * 60, ...extraPayload }; const encoder = new TextEncoder(); const data = base64UrlEncode(JSON.stringify(header)) + "." + base64UrlEncode(JSON.stringify(payload)); const key = await crypto.subtle.importKey( "raw", encoder.encode(secret), { name: "HMAC", hash: "SHA-256" }, false, ["sign"] ); const signature = await crypto.subtle.sign("HMAC", key, encoder.encode(data)); return data + "." + base64UrlEncode(new Uint8Array(signature)); } async function verifyJwt(secret, cookieHeader) { if (!cookieHeader) return false; const cookie = cookieHeader.split(";").find((c) => c.trim().startsWith(`${COOKIE_NAME}=`)); if (!cookie) return false; const token = cookie.split("=")[1]; const parts = token.split("."); if (parts.length !== 3) return false; try { const encoder = new TextEncoder(); const key = await crypto.subtle.importKey( "raw", encoder.encode(secret), { name: "HMAC", hash: "SHA-256" }, false, ["verify"] ); const valid = await crypto.subtle.verify("HMAC", key, base64UrlDecode(parts[2]), encoder.encode(parts[0] + "." + parts[1])); if (!valid) return false; const payload = JSON.parse(new TextDecoder().decode(base64UrlDecode(parts[1]))); if (payload.exp <= Math.floor(Date.now() / 1e3)) return false; return payload; } catch (_) { return false; } } function buildSessionCookie(token, reqUrl = "") { try { const u = new URL(reqUrl || "http://localhost/"); const isHttps = u.protocol === "https:"; const secureFlag = isHttps ? " Secure;" : ""; return `${COOKIE_NAME}=${token}; HttpOnly;${secureFlag} Path=/; SameSite=Strict; Max-Age=86400`; } catch (_) { return `${COOKIE_NAME}=${token}; HttpOnly; Path=/; SameSite=Strict; Max-Age=86400`; } } function base64UrlEncode(data) { const s = typeof data === "string" ? data : String.fromCharCode(...data instanceof Uint8Array ? data : new Uint8Array()); return btoa(s).replace(/\+/g, "-").replace(/\ } async function verifyMailboxLogin(emailAddress, password, DB) { if (!emailAddress || !password) return false; try { const email = emailAddress.toLowerCase().trim(); const result = await DB.prepare("SELECT id, address, local_part, domain, password_hash, can_login FROM mailboxes WHERE address = ?").bind(email).all(); if (result?.results?.length > 0) { const mailbox = result.results[0]; if (!mailbox.can_login) { return false; } let passwordValid = false; if (mailbox.password_hash) { passwordValid = await verifyPassword(password, mailbox.password_hash); } else { passwordValid = password === email; } if (!passwordValid) { return false; } await DB.prepare("UPDATE mailboxes SET last_accessed_at = CURRENT_TIMESTAMP WHERE id = ?").bind(mailbox.id).run(); return { id: mailbox.id, address: mailbox.address, localPart: mailbox.local_part, domain: mailbox.domain, role: "mailbox" }; } return false; } catch (error) { console.error("Mailbox login verification error:", error); return false; } } async function sha256Hex(text) { const encoder = new TextEncoder(); const data = encoder.encode(text); const hashBuffer = await crypto.subtle.digest("SHA-256", data); const hashArray = Array.from(new Uint8Array(hashBuffer)); return hashArray.map((b) => b.toString(16).padStart(2, "0")).join(""); } async function verifyPassword(rawPassword, hashed) { if (!hashed) return false; try { const hex = (await sha256Hex(rawPassword)).toLowerCase(); return hex === String(hashed || "").toLowerCase(); } catch (_) { return false; } } async function hashPassword(password) { return await sha256Hex(password); } function base64UrlDecode(str) { let s = str.replace(/-/g, "+").replace(/_/g, "/"); while (s.length % 4) s += "="; const bin = atob(s); const bytes = new Uint8Array(bin.length); for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i); return bytes; } var COOKIE_NAME; var init_authentication = __esm({ "src/authentication.js"() { COOKIE_NAME = "iding-session"; __name(createJwt, "createJwt"); __name(verifyJwt, "verifyJwt"); __name(buildSessionCookie, "buildSessionCookie"); __name(base64UrlEncode, "base64UrlEncode"); __name(verifyMailboxLogin, "verifyMailboxLogin"); __name(sha256Hex, "sha256Hex"); __name(verifyPassword, "verifyPassword"); __name(hashPassword, "hashPassword"); __name(base64UrlDecode, "base64UrlDecode"); } }); init_cacheHelper(); var _isFirstInit = true; async function initDatabase(db) { try { clearExpiredCache(); if (_isFirstInit) { await performFirstTimeSetup(db); _isFirstInit = false; } else { await db.exec(`PRAGMA foreign_keys = ON;`); } } catch (error) { console.error("\u6570\u636E\u5E93\u521D\u59CB\u5316\u5931\u8D25:", error); throw error; } } __name(initDatabase, "initDatabase"); async function performFirstTimeSetup(db) { try { await db.prepare("SELECT 1 FROM mailboxes LIMIT 1").all(); await db.prepare("SELECT 1 FROM messages LIMIT 1").all(); await db.prepare("SELECT 1 FROM users LIMIT 1").all(); await db.prepare("SELECT 1 FROM user_mailboxes LIMIT 1").all(); await db.prepare("SELECT 1 FROM sent_emails LIMIT 1").all(); return; } catch (e) { console.log("\u68C0\u6D4B\u5230\u6570\u636E\u5E93\u8868\u4E0D\u5B8C\u6574\uFF0C\u5F00\u59CB\u521D\u59CB\u5316..."); } await db.exec(`PRAGMA foreign_keys = OFF;`); await db.exec("CREATE TABLE IF NOT EXISTS mailboxes (id INTEGER PRIMARY KEY AUTOINCREMENT, address TEXT NOT NULL UNIQUE, local_part TEXT NOT NULL, domain TEXT NOT NULL, password_hash TEXT, created_at TEXT DEFAULT CURRENT_TIMESTAMP, last_accessed_at TEXT, expires_at TEXT, is_pinned INTEGER DEFAULT 0, can_login INTEGER DEFAULT 0);"); await db.exec("CREATE TABLE IF NOT EXISTS messages (id INTEGER PRIMARY KEY AUTOINCREMENT, mailbox_id INTEGER NOT NULL, sender TEXT NOT NULL, to_addrs TEXT NOT NULL DEFAULT '', subject TEXT NOT NULL, verification_code TEXT, preview TEXT, r2_bucket TEXT NOT NULL DEFAULT 'mail-eml', r2_object_key TEXT NOT NULL DEFAULT '', received_at TEXT DEFAULT CURRENT_TIMESTAMP, is_read INTEGER DEFAULT 0, FOREIGN KEY(mailbox_id) REFERENCES mailboxes(id));"); await db.exec("CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT NOT NULL UNIQUE, password_hash TEXT, role TEXT NOT NULL DEFAULT 'user', can_send INTEGER NOT NULL DEFAULT 0, mailbox_limit INTEGER NOT NULL DEFAULT 10, created_at TEXT DEFAULT CURRENT_TIMESTAMP);"); await db.exec("CREATE TABLE IF NOT EXISTS user_mailboxes (id INTEGER PRIMARY KEY AUTOINCREMENT, user_id INTEGER NOT NULL, mailbox_id INTEGER NOT NULL, created_at TEXT DEFAULT CURRENT_TIMESTAMP, is_pinned INTEGER NOT NULL DEFAULT 0, UNIQUE(user_id, mailbox_id), FOREIGN KEY(user_id) REFERENCES users(id) ON DELETE CASCADE, FOREIGN KEY(mailbox_id) REFERENCES mailboxes(id) ON DELETE CASCADE);"); await db.exec("CREATE TABLE IF NOT EXISTS sent_emails (id INTEGER PRIMARY KEY AUTOINCREMENT, resend_id TEXT, from_name TEXT, from_addr TEXT NOT NULL, to_addrs TEXT NOT NULL, subject TEXT NOT NULL, html_content TEXT, text_content TEXT, status TEXT DEFAULT 'queued', scheduled_at TEXT, created_at TEXT DEFAULT CURRENT_TIMESTAMP, updated_at TEXT DEFAULT CURRENT_TIMESTAMP);"); await db.exec(`CREATE INDEX IF NOT EXISTS idx_mailboxes_address ON mailboxes(address);`); await db.exec(`CREATE INDEX IF NOT EXISTS idx_mailboxes_is_pinned ON mailboxes(is_pinned DESC);`); await db.exec(`CREATE INDEX IF NOT EXISTS idx_mailboxes_address_created ON mailboxes(address, created_at DESC);`); await db.exec(`CREATE INDEX IF NOT EXISTS idx_messages_mailbox_id ON messages(mailbox_id);`); await db.exec(`CREATE INDEX IF NOT EXISTS idx_messages_received_at ON messages(received_at DESC);`); await db.exec(`CREATE INDEX IF NOT EXISTS idx_messages_r2_object_key ON messages(r2_object_key);`); await db.exec(`CREATE INDEX IF NOT EXISTS idx_messages_mailbox_received ON messages(mailbox_id, received_at DESC);`); await db.exec(`CREATE INDEX IF NOT EXISTS idx_messages_mailbox_received_read ON messages(mailbox_id, received_at DESC, is_read);`); await db.exec(`CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);`); await db.exec(`CREATE INDEX IF NOT EXISTS idx_user_mailboxes_user ON user_mailboxes(user_id);`); await db.exec(`CREATE INDEX IF NOT EXISTS idx_user_mailboxes_mailbox ON user_mailboxes(mailbox_id);`); await db.exec(`CREATE INDEX IF NOT EXISTS idx_user_mailboxes_user_pinned ON user_mailboxes(user_id, is_pinned DESC);`); await db.exec(`CREATE INDEX IF NOT EXISTS idx_user_mailboxes_composite ON user_mailboxes(user_id, mailbox_id, is_pinned);`); await db.exec(`CREATE INDEX IF NOT EXISTS idx_sent_emails_resend_id ON sent_emails(resend_id);`); await db.exec(`CREATE INDEX IF NOT EXISTS idx_sent_emails_status_created ON sent_emails(status, created_at DESC);`); await db.exec(`CREATE INDEX IF NOT EXISTS idx_sent_emails_from_addr ON sent_emails(from_addr);`); await db.exec(`PRAGMA foreign_keys = ON;`); } __name(performFirstTimeSetup, "performFirstTimeSetup"); async function getOrCreateMailboxId(db, address) { const { getCachedMailboxId: getCachedMailboxId2, updateMailboxIdCache: updateMailboxIdCache2 } = await Promise.resolve().then(() => (init_cacheHelper(), cacheHelper_exports)); const normalized = String(address || "").trim().toLowerCase(); if (!normalized) throw new Error("\u65E0\u6548\u7684\u90AE\u7BB1\u5730\u5740"); const cachedId = await getCachedMailboxId2(db, normalized); if (cachedId) { db.prepare("UPDATE mailboxes SET last_accessed_at = CURRENT_TIMESTAMP WHERE id = ?").bind(cachedId).run().catch(() => { }); return cachedId; } let local_part = ""; let domain = ""; const at = normalized.indexOf("@"); if (at > 0 && at < normalized.length - 1) { local_part = normalized.slice(0, at); domain = normalized.slice(at + 1); } if (!local_part || !domain) throw new Error("\u65E0\u6548\u7684\u90AE\u7BB1\u5730\u5740"); const existing = await db.prepare("SELECT id FROM mailboxes WHERE address = ? LIMIT 1").bind(normalized).all(); if (existing.results && existing.results.length > 0) { const id = existing.results[0].id; updateMailboxIdCache2(normalized, id); await db.prepare("UPDATE mailboxes SET last_accessed_at = CURRENT_TIMESTAMP WHERE id = ?").bind(id).run(); return id; } await db.prepare( "INSERT INTO mailboxes (address, local_part, domain, password_hash, last_accessed_at) VALUES (?, ?, ?, NULL, CURRENT_TIMESTAMP)" ).bind(normalized, local_part, domain).run(); const created = await db.prepare("SELECT id FROM mailboxes WHERE address = ? LIMIT 1").bind(normalized).all(); const newId = created.results[0].id; updateMailboxIdCache2(normalized, newId); const { invalidateSystemStatCache: invalidateSystemStatCache2 } = await Promise.resolve().then(() => (init_cacheHelper(), cacheHelper_exports)); invalidateSystemStatCache2("total_mailboxes"); return newId; } __name(getOrCreateMailboxId, "getOrCreateMailboxId"); async function getMailboxIdByAddress(db, address) { const { getCachedMailboxId: getCachedMailboxId2 } = await Promise.resolve().then(() => (init_cacheHelper(), cacheHelper_exports)); const normalized = String(address || "").trim().toLowerCase(); if (!normalized) return null; return await getCachedMailboxId2(db, normalized); } __name(getMailboxIdByAddress, "getMailboxIdByAddress"); async function checkMailboxOwnership(db, address, userId = null) { const normalized = String(address || "").trim().toLowerCase(); if (!normalized) return { exists: false, ownedByUser: false, mailboxId: null }; const res = await db.prepare("SELECT id FROM mailboxes WHERE address = ? LIMIT 1").bind(normalized).all(); if (!res.results || res.results.length === 0) { return { exists: false, ownedByUser: false, mailboxId: null }; } const mailboxId = res.results[0].id; if (!userId) { return { exists: true, ownedByUser: false, mailboxId }; } const ownerRes = await db.prepare( "SELECT id FROM user_mailboxes WHERE user_id = ? AND mailbox_id = ? LIMIT 1" ).bind(userId, mailboxId).all(); const ownedByUser = ownerRes.results && ownerRes.results.length > 0; return { exists: true, ownedByUser, mailboxId }; } __name(checkMailboxOwnership, "checkMailboxOwnership"); async function toggleMailboxPin(db, address, userId) { const normalized = String(address || "").trim().toLowerCase(); if (!normalized) throw new Error("\u65E0\u6548\u7684\u90AE\u7BB1\u5730\u5740"); const uid = Number(userId || 0); if (!uid) throw new Error("\u672A\u767B\u5F55"); const mbRes = await db.prepare("SELECT id FROM mailboxes WHERE address = ? LIMIT 1").bind(normalized).all(); if (!mbRes.results || mbRes.results.length === 0) { throw new Error("\u90AE\u7BB1\u4E0D\u5B58\u5728"); } const mailboxId = mbRes.results[0].id; const umRes = await db.prepare("SELECT id, is_pinned FROM user_mailboxes WHERE user_id = ? AND mailbox_id = ? LIMIT 1").bind(uid, mailboxId).all(); if (!umRes.results || umRes.results.length === 0) { await db.prepare("INSERT INTO user_mailboxes (user_id, mailbox_id, is_pinned) VALUES (?, ?, 1)").bind(uid, mailboxId).run(); return { is_pinned: 1 }; } const currentPin = umRes.results[0].is_pinned ? 1 : 0; const newPin = currentPin ? 0 : 1; await db.prepare("UPDATE user_mailboxes SET is_pinned = ? WHERE user_id = ? AND mailbox_id = ?").bind(newPin, uid, mailboxId).run(); return { is_pinned: newPin }; } __name(toggleMailboxPin, "toggleMailboxPin"); async function recordSentEmail(db, { resendId, fromName, from, to, subject, html, text, status = "queued", scheduledAt = null }) { const toAddrs = Array.isArray(to) ? to.join(",") : String(to || ""); await db.prepare(` INSERT INTO sent_emails (resend_id, from_name, from_addr, to_addrs, subject, html_content, text_content, status, scheduled_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) `).bind(resendId || null, fromName || null, from, toAddrs, subject, html || null, text || null, status, scheduledAt || null).run(); } __name(recordSentEmail, "recordSentEmail"); async function updateSentEmail(db, resendId, fields) { if (!resendId) return; const allowed = ["status", "scheduled_at"]; const setClauses = []; const values = []; for (const key of allowed) { if (key in (fields || {})) { setClauses.push(`${key} = ?`); values.push(fields[key]); } } if (!setClauses.length) return; setClauses.push("updated_at = CURRENT_TIMESTAMP"); const sql = `UPDATE sent_emails SET ${setClauses.join(", ")} WHERE resend_id = ?`; values.push(resendId); await db.prepare(sql).bind(...values).run(); } __name(updateSentEmail, "updateSentEmail"); async function createUser(db, { username, passwordHash = null, role = "user", mailboxLimit = 10 }) { const uname = String(username || "").trim().toLowerCase(); if (!uname) throw new Error("\u7528\u6237\u540D\u4E0D\u80FD\u4E3A\u7A7A"); const r = await db.prepare("INSERT INTO users (username, password_hash, role, mailbox_limit) VALUES (?, ?, ?, ?)").bind(uname, passwordHash, role, Math.max(0, Number(mailboxLimit || 10))).run(); const res = await db.prepare("SELECT id, username, role, mailbox_limit, created_at FROM users WHERE username = ? LIMIT 1").bind(uname).all(); return res?.results?.[0]; } __name(createUser, "createUser"); async function updateUser(db, userId, fields) { const allowed = ["role", "mailbox_limit", "password_hash", "can_send"]; const setClauses = []; const values = []; for (const key of allowed) { if (key in (fields || {})) { setClauses.push(`${key} = ?`); values.push(fields[key]); } } if (!setClauses.length) return; const sql = `UPDATE users SET ${setClauses.join(", ")} WHERE id = ?`; values.push(userId); await db.prepare(sql).bind(...values).run(); const { invalidateUserQuotaCache: invalidateUserQuotaCache2, invalidateSystemStatCache: invalidateSystemStatCache2 } = await Promise.resolve().then(() => (init_cacheHelper(), cacheHelper_exports)); if ("mailbox_limit" in fields) { invalidateUserQuotaCache2(userId); } if ("can_send" in fields) { invalidateSystemStatCache2(`user_can_send_${userId}`); } } __name(updateUser, "updateUser"); async function deleteUser(db, userId) { await db.prepare("DELETE FROM users WHERE id = ?").bind(userId).run(); } __name(deleteUser, "deleteUser"); async function listUsersWithCounts(db, { limit = 50, offset = 0, sort = "desc" } = {}) { const orderDirection = sort === "asc" ? "ASC" : "DESC"; const actualLimit = Math.max(1, Math.min(100, Number(limit) || 50)); const actualOffset = Math.max(0, Number(offset) || 0); const usersSql = ` SELECT u.id, u.username, u.role, u.mailbox_limit, u.can_send, u.created_at FROM users u ORDER BY datetime(u.created_at) ${orderDirection} LIMIT ? OFFSET ? `; const { results: users } = await db.prepare(usersSql).bind(actualLimit, actualOffset).all(); if (!users || users.length === 0) { return []; } const userIds = users.map((u) => u.id); const placeholders = userIds.map(() => "?").join(","); const countSql = ` SELECT user_id, COUNT(1) AS c FROM user_mailboxes WHERE user_id IN (${placeholders}) GROUP BY user_id `; const { results: counts } = await db.prepare(countSql).bind(...userIds).all(); const countMap = new Map(); for (const row of counts || []) { countMap.set(row.user_id, row.c); } return users.map((u) => ({ ...u, mailbox_count: countMap.get(u.id) || 0 })); } __name(listUsersWithCounts, "listUsersWithCounts"); async function assignMailboxToUser(db, { userId = null, username = null, address }) { const { getCachedUserQuota: getCachedUserQuota2, invalidateUserQuotaCache: invalidateUserQuotaCache2 } = await Promise.resolve().then(() => (init_cacheHelper(), cacheHelper_exports)); const normalized = String(address || "").trim().toLowerCase(); if (!normalized) throw new Error("\u90AE\u7BB1\u5730\u5740\u65E0\u6548"); const mailboxId = await getOrCreateMailboxId(db, normalized); let uid = userId; if (!uid) { const uname = String(username || "").trim().toLowerCase(); if (!uname) throw new Error("\u7F3A\u5C11\u7528\u6237\u6807\u8BC6"); const r = await db.prepare("SELECT id FROM users WHERE username = ? LIMIT 1").bind(uname).all(); if (!r.results || !r.results.length) throw new Error("\u7528\u6237\u4E0D\u5B58\u5728"); uid = r.results[0].id; } const quota = await getCachedUserQuota2(db, uid); if (quota.used >= quota.limit) throw new Error("\u5DF2\u8FBE\u5230\u90AE\u7BB1\u4E0A\u9650"); await db.prepare("INSERT OR IGNORE INTO user_mailboxes (user_id, mailbox_id) VALUES (?, ?)").bind(uid, mailboxId).run(); invalidateUserQuotaCache2(uid); return { success: true }; } __name(assignMailboxToUser, "assignMailboxToUser"); async function getUserMailboxes(db, userId, limit = 100) { const sql = ` SELECT m.address, m.created_at, um.is_pinned, COALESCE(m.can_login, 0) AS can_login FROM user_mailboxes um JOIN mailboxes m ON m.id = um.mailbox_id WHERE um.user_id = ? ORDER BY um.is_pinned DESC, datetime(m.created_at) DESC LIMIT ? `; const { results } = await db.prepare(sql).bind(userId, Math.min(limit, 200)).all(); return results || []; } __name(getUserMailboxes, "getUserMailboxes"); async function unassignMailboxFromUser(db, { userId = null, username = null, address }) { const { invalidateUserQuotaCache: invalidateUserQuotaCache2 } = await Promise.resolve().then(() => (init_cacheHelper(), cacheHelper_exports)); const normalized = String(address || "").trim().toLowerCase(); if (!normalized) throw new Error("\u90AE\u7BB1\u5730\u5740\u65E0\u6548"); const mailboxId = await getMailboxIdByAddress(db, normalized); if (!mailboxId) throw new Error("\u90AE\u7BB1\u4E0D\u5B58\u5728"); let uid = userId; if (!uid) { const uname = String(username || "").trim().toLowerCase(); if (!uname) throw new Error("\u7F3A\u5C11\u7528\u6237\u6807\u8BC6"); const r = await db.prepare("SELECT id FROM users WHERE username = ? LIMIT 1").bind(uname).all(); if (!r.results || !r.results.length) throw new Error("\u7528\u6237\u4E0D\u5B58\u5728"); uid = r.results[0].id; } const checkRes = await db.prepare("SELECT id FROM user_mailboxes WHERE user_id = ? AND mailbox_id = ? LIMIT 1").bind(uid, mailboxId).all(); if (!checkRes.results || checkRes.results.length === 0) { throw new Error("\u8BE5\u90AE\u7BB1\u672A\u5206\u914D\u7ED9\u8BE5\u7528\u6237"); } await db.prepare("DELETE FROM user_mailboxes WHERE user_id = ? AND mailbox_id = ?").bind(uid, mailboxId).run(); invalidateUserQuotaCache2(uid); return { success: true }; } __name(unassignMailboxFromUser, "unassignMailboxFromUser"); async function getTotalMailboxCount(db) { const { getCachedSystemStat: getCachedSystemStat2 } = await Promise.resolve().then(() => (init_cacheHelper(), cacheHelper_exports)); try { return await getCachedSystemStat2(db, "total_mailboxes", async (db2) => { const result = await db2.prepare("SELECT COUNT(1) AS count FROM mailboxes").all(); return result?.results?.[0]?.count || 0; }); } catch (error) { console.error("\u83B7\u53D6\u7CFB\u7EDF\u90AE\u7BB1\u603B\u6570\u5931\u8D25:", error); return 0; } } __name(getTotalMailboxCount, "getTotalMailboxCount"); function generateRandomId(length = 8) { const chars = "abcdefghijklmnopqrstuvwxyz0123456789"; let result = ""; const len = Math.max(4, Math.min(32, Number(length) || 8)); for (let i = 0; i < len; i++) { result += chars.charAt(Math.floor(Math.random() * chars.length)); } return result; } __name(generateRandomId, "generateRandomId"); function extractEmail(emailString) { const match = emailString.match(/<(.+?)>/) || emailString.match(/([^\s<>]+@[^\s<>]+)/); return match ? match[1] : emailString; } __name(extractEmail, "extractEmail"); function formatTs(dateMs) { return new Date(dateMs).toISOString().replace("T", " ").slice(0, 19); } __name(formatTs, "formatTs"); function buildMockEmails(count = 6) { const now = Date.now(); const templates = [ (code) => `\u60A8\u7684\u9A8C\u8BC1\u7801\u4E3A ${code}\uFF0C5 \u5206\u949F\u5185\u6709\u6548`, (code) => `Your verification code is ${code}. It expires in 5 minutes`, (code) => `One-time code: ${code}`, (code) => `\u5B89\u5168\u9A8C\u8BC1 \xB7 \u9A8C\u8BC1\u7801 ${code}`, (code) => `Login code is ${code}` ]; return Array.from({ length: count }).map((_, i) => { const id = 1e4 + i; const code = (Math.abs(id * 7919 % 9e5) + 1e5).toString().slice(0, 6); const subject = templates[i % templates.length](code); const content = `\u60A8\u597D\uFF0C\u60A8\u6B63\u5728\u4F53\u9A8C\u6F14\u793A\u6A21\u5F0F\u3002\u9A8C\u8BC1\u7801: ${code} \uFF0C\u8BF7\u5728 5 \u5206\u949F\u5185\u5B8C\u6210\u9A8C\u8BC1\u3002If you did not request it, please ignore.`; const html_content = `<p>\u60A8\u597D\uFF0C\u60A8\u6B63\u5728\u4F53\u9A8C <strong>\u6F14\u793A\u6A21\u5F0F</strong>\u3002</p><p><strong>\u9A8C\u8BC1\u7801: ${code}</strong></p><p>\u8BF7\u5728 5 \u5206\u949F\u5185\u5B8C\u6210\u9A8C\u8BC1\u3002</p>`; return { id, sender: `demo${i}@example.com`, subject, received_at: formatTs(now - i * 6e5), is_read: i > 1, content, html_content }; }); } __name(buildMockEmails, "buildMockEmails"); function buildMockMailboxes(limit = 10, offset = 0, mailDomains = []) { const domains = Array.isArray(mailDomains) ? mailDomains : [mailDomains].filter(Boolean); const now = Date.now(); const size = Math.min(limit, 10); return Array.from({ length: size }).map((_, i) => ({ address: `${generateRandomId(10)}@${domains.length ? domains[(offset + i) % domains.length] : "example.com"}`, created_at: formatTs(now - (offset + i) * 36e5), is_pinned: i < 2 ? 1 : 0, password_is_default: i % 3 === 0 ? 1 : 0, can_login: i < 5 ? 1 : 0 })); } __name(buildMockMailboxes, "buildMockMailboxes"); function buildMockEmailDetail(id = 1e4) { const code = (Math.abs(Number(id) * 7919 % 9e5) + 1e5).toString().slice(0, 6); return { id: Number(id) || 1e4, sender: "noreply@example.com", subject: `\u6F14\u793A\u90AE\u4EF6\u5185\u5BB9\uFF08\u9A8C\u8BC1\u7801 ${code}\uFF09`, received_at: formatTs(Date.now()), content: `\u8FD9\u662F\u6F14\u793A\u6A21\u5F0F\u4E0B\u7684\u90AE\u4EF6\u5185\u5BB9\uFF0C\u4EC5\u7528\u4E8E\u5C55\u793A\u754C\u9762\u6548\u679C\u3002\u9A8C\u8BC1\u7801\uFF1A${code}`, html_content: `<p><strong>\u6F14\u793A\u6A21\u5F0F</strong>\uFF1A\u8BE5\u5185\u5BB9\u4E3A\u6A21\u62DF\u6570\u636E\u3002</p><p>\u9A8C\u8BC1\u7801\uFF1A<strong>${code}</strong></p>` }; } __name(buildMockEmailDetail, "buildMockEmailDetail"); function parseEmailBody(raw) { if (!raw) return { text: "", html: "" }; const { headers: topHeaders, body: topBody } = splitHeadersAndBody(raw); return parseEntity(topHeaders, topBody); } __name(parseEmailBody, "parseEmailBody"); function parseEntity(headers, body) { const ctRaw = headers["content-type"] || ""; const ct = ctRaw.toLowerCase(); const transferEnc = (headers["content-transfer-encoding"] || "").toLowerCase(); const boundary = getBoundary(ctRaw); if (!ct.startsWith("multipart/")) { const decoded = decodeBodyWithCharset(body, transferEnc, ct); const isHtml = ct.includes("text/html"); const isText = ct.includes("text/plain") || !isHtml; if (!ct || ct === "") { const guessHtml = guessHtmlFromRaw(decoded || body || ""); if (guessHtml) return { text: "", html: guessHtml }; } return { text: isText ? decoded : "", html: isHtml ? decoded : "" }; } let text = ""; let html = ""; if (boundary) { const parts = splitMultipart(body, boundary); for (const part of parts) { const { headers: ph, body: pb } = splitHeadersAndBody(part); const pct = (ph["content-type"] || "").toLowerCase(); if (pct.startsWith("multipart/")) { const nested = parseEntity(ph, pb); if (!html && nested.html) html = nested.html; if (!text && nested.text) text = nested.text; } else if (pct.startsWith("message/rfc822")) { const nested = parseEmailBody(pb); if (!html && nested.html) html = nested.html; if (!text && nested.text) text = nested.text; } else if (pct.includes("rfc822-headers")) { continue; } else { const res = parseEntity(ph, pb); if (!html && res.html) html = res.html; if (!text && res.text) text = res.text; } if (text && html) break; } } if (!html) { html = guessHtmlFromRaw(body); if (!html && /<\w+[\s\S]*?>[\s\S]*<\/\w+>/.test(body || "")) { html = body; } } if (!html && text) { html = textToHtml(text); } return { text, html }; } __name(parseEntity, "parseEntity"); function splitHeadersAndBody(input) { const idx = input.indexOf("\r\n\r\n"); const idx2 = idx === -1 ? input.indexOf("\n\n") : idx; const sep = idx !== -1 ? 4 : idx2 !== -1 ? 2 : -1; if (sep === -1) return { headers: {}, body: input }; const rawHeaders = input.slice(0, idx !== -1 ? idx : idx2); const body = input.slice((idx !== -1 ? idx : idx2) + sep); return { headers: parseHeaders(rawHeaders), body }; } __name(splitHeadersAndBody, "splitHeadersAndBody"); function parseHeaders(rawHeaders) { const headers = {}; const lines = rawHeaders.split(/\r?\n/); let lastKey = ""; for (const line of lines) { if (/^\s/.test(line) && lastKey) { headers[lastKey] += " " + line.trim(); continue; } const m = line.match(/^([^:]+):\s*(.*)$/); if (m) { lastKey = m[1].toLowerCase(); headers[lastKey] = m[2]; } } return headers; } __name(parseHeaders, "parseHeaders"); function getBoundary(contentType) { if (!contentType) return ""; const m = contentType.match(/boundary\s*=\s*"?([^";\r\n]+)"?/i); return m ? m[1].trim() : ""; } __name(getBoundary, "getBoundary"); function splitMultipart(body, boundary) { const delim = "--" + boundary; const endDelim = delim + "--"; const lines = body.split(/\r?\n/); const parts = []; let current = []; let inPart = false; for (const rawLine of lines) { const line = rawLine.trimEnd(); if (line.trim() === delim) { if (inPart && current.length) parts.push(current.join("\n")); current = []; inPart = true; continue; } if (line.trim() === endDelim) { if (inPart && current.length) parts.push(current.join("\n")); break; } if (inPart) current.push(rawLine); } return parts; } __name(splitMultipart, "splitMultipart"); function decodeBody(body, transferEncoding) { if (!body) return ""; const enc = transferEncoding.trim(); if (enc === "base64") { const cleaned = body.replace(/\s+/g, ""); try { const bin = atob(cleaned); const bytes = new Uint8Array(bin.length); for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i); try { return new TextDecoder("utf-8", { fatal: false }).decode(bytes); } catch (_) { return bin; } } catch (_) { return body; } } if (enc === "quoted-printable") { return decodeQuotedPrintable(body); } return body; } __name(decodeBody, "decodeBody"); function decodeBodyWithCharset(body, transferEncoding, contentType) { const decodedRaw = decodeBody(body, transferEncoding); const m = /charset\s*=\s*"?([^";]+)/i.exec(contentType || ""); const charset = (m && m[1] ? m[1].trim().toLowerCase() : "") || "utf-8"; if (!decodedRaw) return ""; if (charset === "utf-8" || charset === "utf8" || charset === "us-ascii") return decodedRaw; try { const bytes = new Uint8Array(decodedRaw.split("").map((c) => c.charCodeAt(0))); return new TextDecoder(charset, { fatal: false }).decode(bytes); } catch (_) { return decodedRaw; } } __name(decodeBodyWithCharset, "decodeBodyWithCharset"); function decodeQuotedPrintable(input) { let s = input.replace(/=\r?\n/g, ""); const bytes = []; for (let i = 0; i < s.length; i++) { const ch = s[i]; if (ch === "=" && i + 2 < s.length) { const hex = s.substring(i + 1, i + 3); if (/^[0-9A-Fa-f]{2}$/.test(hex)) { bytes.push(parseInt(hex, 16)); i += 2; continue; } } bytes.push(ch.charCodeAt(0)); } try { return new TextDecoder("utf-8", { fatal: false }).decode(new Uint8Array(bytes)); } catch (_) { return s; } } __name(decodeQuotedPrintable, "decodeQuotedPrintable"); function guessHtmlFromRaw(raw) { if (!raw) return ""; const lower = raw.toLowerCase(); let hs = lower.indexOf("<html"); if (hs === -1) hs = lower.indexOf("<!doctype html"); if (hs !== -1) { const he = lower.lastIndexOf("</html>"); if (he !== -1) return raw.slice(hs, he + 7); } return ""; } __name(guessHtmlFromRaw, "guessHtmlFromRaw"); function escapeHtml(s) { return s.replace(/[&<>"']/g, (c) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" })[c] || c); } __name(escapeHtml, "escapeHtml"); function textToHtml(text) { return `<div style="white-space:pre-wrap">${escapeHtml(text)}</div>`; } __name(textToHtml, "textToHtml"); function stripHtml(html) { const s = String(html || ""); return s.replace(/<script[\s\S]*?<\/script>/gi, " ").replace(/<style[\s\S]*?<\/style>/gi, " ").replace(/<[^>]+>/g, " ").replace(/&nbsp;/gi, " ").replace(/&#(\d+);/g, (_, n) => { try { return String.fromCharCode(parseInt(n, 10)); } catch (_2) { return " "; } }).replace(/&[a-z]+;/gi, " ").replace(/\s+/g, " ").trim(); } __name(stripHtml, "stripHtml"); function extractVerificationCode({ subject = "", text = "", html = "" } = {}) { const subjectText = String(subject || ""); const textBody = String(text || ""); const htmlBody = stripHtml(html); const sources = { subject: subjectText, body: `${textBody} ${htmlBody}`.trim() }; const minLen = 4; const maxLen = 8; function normalizeDigits(s) { const digits = String(s || "").replace(/\D+/g, ""); if (digits.length >= minLen && digits.length <= maxLen) return digits; return ""; } __name(normalizeDigits, "normalizeDigits"); const kw = "(?:verification|one[-s]?time|two[-s]?factor|2fa|security|auth|login|confirm|code|otp|\u9A8C\u8BC1\u7801|\u6821\u9A8C\u7801|\u9A57\u8B49\u78BC|\u78BA\u8A8D\u78BC|\u8A8D\u8B49\u78BC|\u8A8D\u8A3C\u30B3\u30FC\u30C9|\uC778\uC99D\uCF54\uB4DC|\uCF54\uB4DC)"; const sepClass = "[\\u00A0\\s-\u2013\u2014_.\xB7\u2022\u2219\u2027'\u2019]"; const codeChunk = `([0-9](?:${sepClass}?[0-9]){3,7})`; const subjectOrdereds = [ new RegExp(`${kw}[^ \rd]{0,20}(?<!\\d)${codeChunk}(?!\\d)`, "i"), new RegExp(`(?<!\\d)${codeChunk}(?!\\d)[^ \rd]{0,20}${kw}`, "i") ]; for (const r of subjectOrdereds) { const m = sources.subject.match(r); if (m && m[1]) { const n = normalizeDigits(m[1]); if (n) return n; } } const bodyOrdereds = [ new RegExp(`${kw}[^ \rd]{0,30}(?<!\\d)${codeChunk}(?!\\d)`, "i"), new RegExp(`(?<!\\d)${codeChunk}(?!\\d)[^ \rd]{0,30}${kw}`, "i") ]; for (const r of bodyOrdereds) { const m = sources.body.match(r); if (m && m[1]) { const n = normalizeDigits(m[1]); if (n) return n; } } const looseBodyOrdereds = [ new RegExp(`${kw}[^ \rd]{0,80}(?<!\\d)${codeChunk}(?!\\d)`, "i"), new RegExp(`(?<!\\d)${codeChunk}(?!\\d)[^ \rd]{0,80}${kw}`, "i") ]; for (const r of looseBodyOrdereds) { const m = sources.body.match(r); if (m && m[1]) { const n = normalizeDigits(m[1]); if (n && !isLikelyNonVerificationCode(n, sources.body)) { return n; } } } return ""; } __name(extractVerificationCode, "extractVerificationCode"); function isLikelyNonVerificationCode(digits, context = "") { if (!digits) return true; const year = parseInt(digits, 10); if (digits.length === 4 && year >= 2e3 && year <= 2099) { return true; } if (digits.length === 5) { const lowerContext = context.toLowerCase(); if (lowerContext.includes("address") || lowerContext.includes("street") || lowerContext.includes("zip") || lowerContext.includes("postal") || /\b[a-z]{2,}\s+\d{5}\b/i.test(context)) { return true; } } const addressPattern = new RegExp(`\\b${digits}\\s+[A-Z][a-z]+(?:,|\\b)`, "i"); if (addressPattern.test(context)) { return true; } return false; } __name(isLikelyNonVerificationCode, "isLikelyNonVerificationCode"); function parseResendConfig(resendToken) { const config = {}; if (!resendToken) return config; try { const jsonConfig = JSON.parse(resendToken); if (typeof jsonConfig === "object" && jsonConfig !== null) { return jsonConfig; } } catch (_) { } const pairs = String(resendToken).split(","); for (const pair of pairs) { const [domain, apiKey] = pair.split("=").map((s) => s.trim()); if (domain && apiKey) { config[domain.toLowerCase()] = apiKey; } } return config; } __name(parseResendConfig, "parseResendConfig"); function selectApiKeyForDomain(fromEmail, resendConfig) { if (!fromEmail) return ""; if (typeof resendConfig === "string" && !resendConfig.includes("=")) { return resendConfig; } const config = typeof resendConfig === "object" ? resendConfig : parseResendConfig(resendConfig); const emailMatch = String(fromEmail).match(/@([^>]+)/); if (!emailMatch) return ""; const domain = emailMatch[1].toLowerCase().trim(); return config[domain] || ""; } __name(selectApiKeyForDomain, "selectApiKeyForDomain"); function buildHeaders(apiKey) { return { "Authorization": `Bearer ${apiKey}`, "Content-Type": "application/json" }; } __name(buildHeaders, "buildHeaders"); function normalizeSendPayload(payload) { const { from, to, subject, html, text, cc, bcc, replyTo, headers, attachments, scheduledAt } = payload || {}; const body = { from, to: Array.isArray(to) ? to : to ? [to] : [], subject, html, text }; if (payload && typeof payload.fromName === "string" && from) { const displayName = payload.fromName.trim(); if (displayName) { body.from = `${displayName} <${from}>`; } } if (cc) body.cc = Array.isArray(cc) ? cc : [cc]; if (bcc) body.bcc = Array.isArray(bcc) ? bcc : [bcc]; if (replyTo) body.reply_to = replyTo; if (headers && typeof headers === "object") body.headers = headers; if (attachments && Array.isArray(attachments)) body.attachments = attachments; if (scheduledAt) body.scheduled_at = scheduledAt; return body; } __name(normalizeSendPayload, "normalizeSendPayload"); async function sendEmailWithResend(apiKey, payload) { const body = normalizeSendPayload(payload); const resp = await fetch("https: method: "POST", headers: buildHeaders(apiKey), body: JSON.stringify(body) }); const data = await resp.json().catch(() => ({})); if (!resp.ok) { const msg = data?.message || data?.error || resp.statusText || "Resend send failed"; throw new Error(msg); } return data; } __name(sendEmailWithResend, "sendEmailWithResend"); async function sendEmailWithAutoResend(resendConfig, payload) { const apiKey = selectApiKeyForDomain(payload.from, resendConfig); if (!apiKey) { throw new Error(`\u672A\u627E\u5230\u57DF\u540D\u5BF9\u5E94\u7684API\u5BC6\u94A5: ${payload.from}`); } return await sendEmailWithResend(apiKey, payload); } __name(sendEmailWithAutoResend, "sendEmailWithAutoResend"); async function sendBatchWithResend(apiKey, payloads) { const items = Array.isArray(payloads) ? payloads.map(normalizeSendPayload) : []; const resp = await fetch("https: method: "POST", headers: buildHeaders(apiKey), body: JSON.stringify(items) }); const data = await resp.json().catch(() => ({})); if (!resp.ok) { const msg = data?.message || data?.error || resp.statusText || "Resend batch send failed"; throw new Error(msg); } return data; } __name(sendBatchWithResend, "sendBatchWithResend"); async function sendBatchWithAutoResend(resendConfig, payloads) { if (!Array.isArray(payloads) || payloads.length === 0) { return []; } const groupedByDomain = {}; for (const payload of payloads) { const apiKey = selectApiKeyForDomain(payload.from, resendConfig); if (!apiKey) { throw new Error(`\u672A\u627E\u5230\u57DF\u540D\u5BF9\u5E94\u7684API\u5BC6\u94A5: ${payload.from}`); } if (!groupedByDomain[apiKey]) { groupedByDomain[apiKey] = []; } groupedByDomain[apiKey].push(payload); } const results = []; const promises = Object.entries(groupedByDomain).map(async ([apiKey, groupPayloads]) => { try { const batchResult = await sendBatchWithResend(apiKey, groupPayloads); return { success: true, apiKey, results: batchResult }; } catch (error) { return { success: false, apiKey, error: error.message }; } }); const batchResults = await Promise.all(promises); for (const batchResult of batchResults) { if (batchResult.success) { if (Array.isArray(batchResult.results)) { results.push(...batchResult.results); } else { results.push(batchResult.results); } } else { throw new Error(`\u6279\u91CF\u53D1\u9001\u5931\u8D25 (API\u5BC6\u94A5: ${batchResult.apiKey}): ${batchResult.error}`); } } return results; } __name(sendBatchWithAutoResend, "sendBatchWithAutoResend"); async function getEmailFromResend(apiKey, id) { const resp = await fetch(`https: method: "GET", headers: buildHeaders(apiKey) }); const data = await resp.json().catch(() => ({})); if (!resp.ok) { const msg = data?.message || data?.error || resp.statusText || "Resend get failed"; throw new Error(msg); } return data; } __name(getEmailFromResend, "getEmailFromResend"); async function updateEmailInResend(apiKey, { id, scheduledAt }) { const body = {}; if (scheduledAt) body.scheduled_at = scheduledAt; const resp = await fetch(`https: method: "PATCH", headers: buildHeaders(apiKey), body: JSON.stringify(body) }); const data = await resp.json().catch(() => ({})); if (!resp.ok) { const msg = data?.message || data?.error || resp.statusText || "Resend update failed"; throw new Error(msg); } return data; } __name(updateEmailInResend, "updateEmailInResend"); async function cancelEmailInResend(apiKey, id) { const resp = await fetch(`https: method: "POST", headers: buildHeaders(apiKey) }); const data = await resp.json().catch(() => ({})); if (!resp.ok) { const msg = data?.message || data?.error || resp.statusText || "Resend cancel failed"; throw new Error(msg); } return data; } __name(cancelEmailInResend, "cancelEmailInResend"); async function handleApiRequest(request, db, mailDomains, options = { mockOnly: false, resendApiKey: "", adminName: "", r2: null, authPayload: null, mailboxOnly: false }) { const url = new URL(request.url); const path = url.pathname; const isMock = !!options.mockOnly; const isMailboxOnly = !!options.mailboxOnly; const MOCK_DOMAINS = ["exa.cc", "exr.yp", "duio.ty"]; const RESEND_API_KEY = options.resendApiKey || ""; if (isMailboxOnly) { const payload = getJwtPayload(); const mailboxAddress = payload?.mailboxAddress; const mailboxId = payload?.mailboxId; const allowedPaths = ["/api/emails", "/api/email/", "/api/auth", "/api/quota", "/api/mailbox/password"]; const isAllowedPath = allowedPaths.some((allowedPath) => path.startsWith(allowedPath)); if (!isAllowedPath) { return new Response("\u8BBF\u95EE\u88AB\u62D2\u7EDD", { status: 403 }); } if (path === "/api/emails" && request.method === "GET") { const requestedMailbox = url.searchParams.get("mailbox"); if (requestedMailbox && requestedMailbox.toLowerCase() !== mailboxAddress?.toLowerCase()) { return new Response("\u53EA\u80FD\u8BBF\u95EE\u81EA\u5DF1\u7684\u90AE\u7BB1", { status: 403 }); } if (!requestedMailbox && mailboxAddress) { url.searchParams.set("mailbox", mailboxAddress); } } if (path.startsWith("/api/email/") && mailboxId) { const emailId = path.split("/")[3]; if (emailId && emailId !== "batch") { try { const { results } = await db.prepare("SELECT mailbox_id FROM messages WHERE id = ? LIMIT 1").bind(emailId).all(); if (!results || results.length === 0) { return new Response("\u90AE\u4EF6\u4E0D\u5B58\u5728", { status: 404 }); } if (results[0].mailbox_id !== mailboxId) { return new Response("\u65E0\u6743\u8BBF\u95EE\u6B64\u90AE\u4EF6", { status: 403 }); } } catch (e) { return new Response("\u9A8C\u8BC1\u5931\u8D25", { status: 500 }); } } } } function getJwtPayload() { if (options && options.authPayload) return options.authPayload; try { const cookie = request.headers.get("Cookie") || ""; const token = (cookie.split(";").find((s) => s.trim().startsWith("iding-session=")) || "").split("=")[1] || ""; const parts = token.split("."); if (parts.length === 3) { const json = atob(parts[1].replace(/-/g, "+").replace(/_/g, "/")); return JSON.parse(json); } } catch (_) { } return null; } __name(getJwtPayload, "getJwtPayload"); function isStrictAdmin() { const p = getJwtPayload(); if (!p) return false; if (p.role !== "admin") return false; if (String(p.username || "") === "__root__") return true; if (options?.adminName) { return String(p.username || "").toLowerCase() === String(options.adminName || "").toLowerCase(); } return true; } __name(isStrictAdmin, "isStrictAdmin"); async function sha256Hex3(text) { const enc = new TextEncoder(); const data = enc.encode(String(text || "")); const digest = await crypto.subtle.digest("SHA-256", data); const bytes = new Uint8Array(digest); let out = ""; for (let i = 0; i < bytes.length; i++) out += bytes[i].toString(16).padStart(2, "0"); return out; } __name(sha256Hex3, "sha256Hex"); if (!globalThis.__MOCK_USERS__) { const now = new Date(); globalThis.__MOCK_USERS__ = [ { id: 1, username: "demo1", role: "user", can_send: 0, mailbox_limit: 5, created_at: now.toISOString().replace("T", " ").slice(0, 19) }, { id: 2, username: "demo2", role: "user", can_send: 0, mailbox_limit: 8, created_at: now.toISOString().replace("T", " ").slice(0, 19) }, { id: 3, username: "operator", role: "admin", can_send: 0, mailbox_limit: 20, created_at: now.toISOString().replace("T", " ").slice(0, 19) } ]; globalThis.__MOCK_USER_MAILBOXES__ = new Map(); try { const domains = MOCK_DOMAINS; for (const u of globalThis.__MOCK_USERS__) { const maxCount = Math.min(u.mailbox_limit || 10, 8); const minCount = Math.min(3, maxCount); const count = Math.max(minCount, Math.min(maxCount, Math.floor(Math.random() * (maxCount - minCount + 1)) + minCount)); const boxes = buildMockMailboxes(count, 0, domains); globalThis.__MOCK_USER_MAILBOXES__.set(u.id, boxes); } } catch (_) { } globalThis.__MOCK_USER_LAST_ID__ = 3; } if (isMock && path === "/api/users" && request.method === "GET") { const limit = Math.min(parseInt(url.searchParams.get("limit") || "50", 10), 100); const offset = Math.max(parseInt(url.searchParams.get("offset") || "0", 10), 0); const sort = url.searchParams.get("sort") || "desc"; let list = (globalThis.__MOCK_USERS__ || []).map((u) => { const boxes = globalThis.__MOCK_USER_MAILBOXES__?.get(u.id) || []; return { ...u, mailbox_count: boxes.length }; }); list.sort((a, b) => { const dateA = new Date(a.created_at); const dateB = new Date(b.created_at); return sort === "asc" ? dateA - dateB : dateB - dateA; }); const result = list.slice(offset, offset + limit); return Response.json(result); } if (isMock && path === "/api/users" && request.method === "POST") { try { const body = await request.json(); const username = String(body.username || "").trim().toLowerCase(); if (!username) return new Response("\u7528\u6237\u540D\u4E0D\u80FD\u4E3A\u7A7A", { status: 400 }); const exists = (globalThis.__MOCK_USERS__ || []).some((u) => u.username === username); if (exists) return new Response("\u7528\u6237\u540D\u5DF2\u5B58\u5728", { status: 400 }); const role = body.role === "admin" ? "admin" : "user"; const mailbox_limit = Math.max(0, Number(body.mailboxLimit || 10)); const id = ++globalThis.__MOCK_USER_LAST_ID__; const item = { id, username, role, can_send: 0, mailbox_limit, created_at: ( new Date()).toISOString().replace("T", " ").slice(0, 19) }; globalThis.__MOCK_USERS__.unshift(item); return Response.json(item); } catch (e) { return new Response("\u521B\u5EFA\u5931\u8D25", { status: 500 }); } } if (isMock && request.method === "PATCH" && path.startsWith("/api/users/")) { const id = Number(path.split("/")[3]); const list = globalThis.__MOCK_USERS__ || []; const idx = list.findIndex((u) => u.id === id); if (idx < 0) return new Response("\u672A\u627E\u5230\u7528\u6237", { status: 404 }); try { const body = await request.json(); if (typeof body.mailboxLimit !== "undefined") list[idx].mailbox_limit = Math.max(0, Number(body.mailboxLimit)); if (typeof body.role === "string") list[idx].role = body.role === "admin" ? "admin" : "user"; if (typeof body.can_send !== "undefined") list[idx].can_send = body.can_send ? 1 : 0; return Response.json({ success: true }); } catch (_) { return new Response("\u66F4\u65B0\u5931\u8D25", { status: 500 }); } } if (isMock && request.method === "DELETE" && path.startsWith("/api/users/")) { const id = Number(path.split("/")[3]); const list = globalThis.__MOCK_USERS__ || []; const idx = list.findIndex((u) => u.id === id); if (idx < 0) return new Response("\u672A\u627E\u5230\u7528\u6237", { status: 404 }); list.splice(idx, 1); globalThis.__MOCK_USER_MAILBOXES__?.delete(id); return Response.json({ success: true }); } if (isMock && path === "/api/users/assign" && request.method === "POST") { try { const body = await request.json(); const username = String(body.username || "").trim().toLowerCase(); const address = String(body.address || "").trim().toLowerCase(); const u = (globalThis.__MOCK_USERS__ || []).find((x) => x.username === username); if (!u) return new Response("\u7528\u6237\u4E0D\u5B58\u5728", { status: 404 }); const boxes = globalThis.__MOCK_USER_MAILBOXES__?.get(u.id) || []; if (boxes.length >= (u.mailbox_limit || 10)) return new Response("\u5DF2\u8FBE\u5230\u90AE\u7BB1\u4E0A\u9650", { status: 400 }); const item = { address, created_at: ( new Date()).toISOString().replace("T", " ").slice(0, 19), is_pinned: 0 }; boxes.unshift(item); globalThis.__MOCK_USER_MAILBOXES__?.set(u.id, boxes); return Response.json({ success: true }); } catch (_) { return new Response("\u5206\u914D\u5931\u8D25", { status: 500 }); } } if (isMock && path === "/api/users/unassign" && request.method === "POST") { try { const body = await request.json(); const username = String(body.username || "").trim().toLowerCase(); const address = String(body.address || "").trim().toLowerCase(); const u = (globalThis.__MOCK_USERS__ || []).find((x) => x.username === username); if (!u) return new Response("\u7528\u6237\u4E0D\u5B58\u5728", { status: 404 }); const boxes = globalThis.__MOCK_USER_MAILBOXES__?.get(u.id) || []; const index = boxes.findIndex((box) => box.address === address); if (index === -1) return new Response("\u8BE5\u90AE\u7BB1\u672A\u5206\u914D\u7ED9\u8BE5\u7528\u6237", { status: 400 }); boxes.splice(index, 1); globalThis.__MOCK_USER_MAILBOXES__?.set(u.id, boxes); return Response.json({ success: true }); } catch (_) { return new Response("\u53D6\u6D88\u5206\u914D\u5931\u8D25", { status: 500 }); } } if (isMock && request.method === "GET" && path.startsWith("/api/users/") && path.endsWith("/mailboxes")) { const id = Number(path.split("/")[3]); const all = globalThis.__MOCK_USER_MAILBOXES__?.get(id) || []; const n = Math.min(all.length, Math.max(3, Math.min(8, Math.floor(Math.random() * 6) + 3))); const list = all.slice(0, n); return Response.json(list); } if (path === "/api/domains" && request.method === "GET") { if (isMock) return Response.json(MOCK_DOMAINS); const domains = Array.isArray(mailDomains) ? mailDomains : [mailDomains || "temp.example.com"]; return Response.json(domains); } if (path === "/api/generate") { const lengthParam = Number(url.searchParams.get("length") || 0); const randomId = generateRandomId(lengthParam || void 0); const domains = isMock ? MOCK_DOMAINS : Array.isArray(mailDomains) ? mailDomains : [mailDomains || "temp.example.com"]; const domainIdx = Math.max(0, Math.min(domains.length - 1, Number(url.searchParams.get("domainIndex") || 0))); const chosenDomain = domains[domainIdx] || domains[0]; const email = `${randomId}@${chosenDomain}`; if (!isMock) { try { const payload = getJwtPayload(); if (payload?.userId) { await assignMailboxToUser(db, { userId: payload.userId, address: email }); return Response.json({ email, expires: Date.now() + 36e5 }); } await getOrCreateMailboxId(db, email); return Response.json({ email, expires: Date.now() + 36e5 }); } catch (e) { return new Response(String(e?.message || "\u521B\u5EFA\u5931\u8D25"), { status: 400 }); } } return Response.json({ email, expires: Date.now() + 36e5 }); } if (!isMock && path === "/api/users" && request.method === "GET") { if (!isStrictAdmin()) return new Response("Forbidden", { status: 403 }); const limit = Math.min(parseInt(url.searchParams.get("limit") || "50", 10), 100); const offset = Math.max(parseInt(url.searchParams.get("offset") || "0", 10), 0); const sort = url.searchParams.get("sort") || "desc"; try { const users = await listUsersWithCounts(db, { limit, offset, sort }); return Response.json(users); } catch (e) { return new Response("\u67E5\u8BE2\u5931\u8D25", { status: 500 }); } } if (!isMock && path === "/api/users" && request.method === "POST") { if (!isStrictAdmin()) return new Response("Forbidden", { status: 403 }); try { const body = await request.json(); const username = String(body.username || "").trim(); const role = (body.role || "user") === "admin" ? "admin" : "user"; const mailboxLimit = Number(body.mailboxLimit || 10); const password = String(body.password || "").trim(); let passwordHash = null; if (password) { passwordHash = await sha256Hex3(password); } const user = await createUser(db, { username, passwordHash, role, mailboxLimit }); return Response.json(user); } catch (e) { return new Response("\u521B\u5EFA\u5931\u8D25: " + (e?.message || e), { status: 500 }); } } if (!isMock && request.method === "PATCH" && path.startsWith("/api/users/")) { if (!isStrictAdmin()) return new Response("Forbidden", { status: 403 }); const id = Number(path.split("/")[3]); if (!id) return new Response("\u65E0\u6548ID", { status: 400 }); try { const body = await request.json(); const fields = {}; if (typeof body.mailboxLimit !== "undefined") fields.mailbox_limit = Math.max(0, Number(body.mailboxLimit)); if (typeof body.role === "string") fields.role = body.role === "admin" ? "admin" : "user"; if (typeof body.can_send !== "undefined") fields.can_send = body.can_send ? 1 : 0; if (typeof body.password === "string" && body.password) { fields.password_hash = await sha256Hex3(String(body.password)); } await updateUser(db, id, fields); return Response.json({ success: true }); } catch (e) { return new Response("\u66F4\u65B0\u5931\u8D25: " + (e?.message || e), { status: 500 }); } } if (!isMock && request.method === "DELETE" && path.startsWith("/api/users/")) { if (!isStrictAdmin()) return new Response("Forbidden", { status: 403 }); const id = Number(path.split("/")[3]); if (!id) return new Response("\u65E0\u6548ID", { status: 400 }); try { await deleteUser(db, id); return Response.json({ success: true }); } catch (e) { return new Response("\u5220\u9664\u5931\u8D25: " + (e?.message || e), { status: 500 }); } } if (!isMock && path === "/api/users/assign" && request.method === "POST") { if (!isStrictAdmin()) return new Response("Forbidden", { status: 403 }); try { const body = await request.json(); const username = String(body.username || "").trim(); const address = String(body.address || "").trim().toLowerCase(); if (!username || !address) return new Response("\u53C2\u6570\u4E0D\u5B8C\u6574", { status: 400 }); const result = await assignMailboxToUser(db, { username, address }); return Response.json(result); } catch (e) { return new Response("\u5206\u914D\u5931\u8D25: " + (e?.message || e), { status: 500 }); } } if (!isMock && path === "/api/users/unassign" && request.method === "POST") { if (!isStrictAdmin()) return new Response("Forbidden", { status: 403 }); try { const body = await request.json(); const username = String(body.username || "").trim(); const address = String(body.address || "").trim().toLowerCase(); if (!username || !address) return new Response("\u53C2\u6570\u4E0D\u5B8C\u6574", { status: 400 }); const result = await unassignMailboxFromUser(db, { username, address }); return Response.json(result); } catch (e) { return new Response("\u53D6\u6D88\u5206\u914D\u5931\u8D25: " + (e?.message || e), { status: 500 }); } } if (!isMock && request.method === "GET" && path.startsWith("/api/users/") && path.endsWith("/mailboxes")) { const id = Number(path.split("/")[3]); if (!id) return new Response("\u65E0\u6548ID", { status: 400 }); try { const list = await getUserMailboxes(db, id); return Response.json(list || []); } catch (e) { return new Response("\u67E5\u8BE2\u5931\u8D25", { status: 500 }); } } if (path === "/api/create" && request.method === "POST") { if (isMock) { try { const body = await request.json(); const local = String(body.local || "").trim().toLowerCase(); const valid = /^[a-z0-9._-]{1,64}$/i.test(local); if (!valid) return new Response("\u975E\u6CD5\u7528\u6237\u540D", { status: 400 }); const domains = MOCK_DOMAINS; const domainIdx = Math.max(0, Math.min(domains.length - 1, Number(body.domainIndex || 0))); const chosenDomain = domains[domainIdx] || domains[0]; const email = `${local}@${chosenDomain}`; return Response.json({ email, expires: Date.now() + 36e5 }); } catch (_) { return new Response("Bad Request", { status: 400 }); } } try { const body = await request.json(); const local = String(body.local || "").trim().toLowerCase(); const valid = /^[a-z0-9._-]{1,64}$/i.test(local); if (!valid) return new Response("\u975E\u6CD5\u7528\u6237\u540D", { status: 400 }); const domains = Array.isArray(mailDomains) ? mailDomains : [mailDomains || "temp.example.com"]; const domainIdx = Math.max(0, Math.min(domains.length - 1, Number(body.domainIndex || 0))); const chosenDomain = domains[domainIdx] || domains[0]; const email = `${local}@${chosenDomain}`; try { const payload = getJwtPayload(); const userId = payload?.userId; const ownership = await checkMailboxOwnership(db, email, userId); if (ownership.exists) { if (userId && ownership.ownedByUser) { return new Response("\u90AE\u7BB1\u5730\u5740\u5DF2\u5B58\u5728\uFF0C\u4F7F\u7528\u5176\u4ED6\u5730\u5740", { status: 409 }); } else if (userId && !ownership.ownedByUser) { return new Response("\u90AE\u7BB1\u5730\u5740\u5DF2\u88AB\u5360\u7528\uFF0C\u8BF7\u5411\u7BA1\u7406\u5458\u7533\u8BF7\u6216\u4F7F\u7528\u5176\u4ED6\u5730\u5740", { status: 409 }); } else { return new Response("\u90AE\u7BB1\u5730\u5740\u5DF2\u5B58\u5728\uFF0C\u4F7F\u7528\u5176\u4ED6\u5730\u5740", { status: 409 }); } } if (userId) { await assignMailboxToUser(db, { userId, address: email }); return Response.json({ email, expires: Date.now() + 36e5 }); } else { await getOrCreateMailboxId(db, email); return Response.json({ email, expires: Date.now() + 36e5 }); } } catch (e) { if (String(e?.message || "").includes("\u5DF2\u8FBE\u5230\u90AE\u7BB1\u4E0A\u9650")) { return new Response("\u5DF2\u8FBE\u5230\u90AE\u7BB1\u521B\u5EFA\u4E0A\u9650", { status: 429 }); } return new Response(String(e?.message || "\u521B\u5EFA\u5931\u8D25"), { status: 400 }); } } catch (e) { return new Response("\u521B\u5EFA\u5931\u8D25", { status: 500 }); } } if (path === "/api/user/quota" && request.method === "GET") { if (isMock) { return Response.json({ used: 0, limit: 999999, isAdmin: true }); } try { const payload = getJwtPayload(); const uid = Number(payload?.userId || 0); const role = payload?.role || "user"; const username = String(payload?.username || "").trim().toLowerCase(); const adminName = String(options.adminName || "admin").trim().toLowerCase(); const isSuperAdmin = role === "admin" && (username === adminName || username === "__root__"); if (isSuperAdmin) { const totalUsed = await getTotalMailboxCount(db); return Response.json({ used: totalUsed, limit: 999999, isAdmin: true }); } else if (uid) { const { getCachedUserQuota: getCachedUserQuota2 } = await Promise.resolve().then(() => (init_cacheHelper(), cacheHelper_exports)); const quota = await getCachedUserQuota2(db, uid); return Response.json({ ...quota, isAdmin: false }); } else { return Response.json({ used: 0, limit: 0, isAdmin: false }); } } catch (_) { return new Response("\u67E5\u8BE2\u5931\u8D25", { status: 500 }); } } if (path === "/api/sent" && request.method === "GET") { if (isMock) { return Response.json([]); } const from = url.searchParams.get("from") || url.searchParams.get("mailbox") || ""; if (!from) { return new Response("\u7F3A\u5C11 from \u53C2\u6570", { status: 400 }); } try { const limit = Math.min(parseInt(url.searchParams.get("limit") || "20", 10), 50); const { results } = await db.prepare(` SELECT id, resend_id, to_addrs as recipients, subject, created_at, status FROM sent_emails WHERE from_addr = ? ORDER BY datetime(created_at) DESC LIMIT ? `).bind(String(from).trim().toLowerCase(), limit).all(); return Response.json(results || []); } catch (e) { console.error("\u67E5\u8BE2\u53D1\u4EF6\u8BB0\u5F55\u5931\u8D25:", e); return new Response("\u67E5\u8BE2\u53D1\u4EF6\u8BB0\u5F55\u5931\u8D25", { status: 500 }); } } if (request.method === "GET" && path.startsWith("/api/sent/")) { if (isMock) { return new Response("\u6F14\u793A\u6A21\u5F0F\u4E0D\u53EF\u67E5\u8BE2\u771F\u5B9E\u53D1\u9001", { status: 403 }); } const id = path.split("/")[3]; try { const { results } = await db.prepare(` SELECT id, resend_id, from_addr, to_addrs as recipients, subject, html_content, text_content, status, scheduled_at, created_at FROM sent_emails WHERE id = ? `).bind(id).all(); if (!results || !results.length) return new Response("\u672A\u627E\u5230\u53D1\u4EF6", { status: 404 }); return Response.json(results[0]); } catch (e) { return new Response("\u67E5\u8BE2\u5931\u8D25", { status: 500 }); } } async function checkSendPermission() { const payload = getJwtPayload(); if (!payload) return false; if (payload.role === "admin") return true; if (payload.userId) { const { getCachedSystemStat: getCachedSystemStat2 } = await Promise.resolve().then(() => (init_cacheHelper(), cacheHelper_exports)); const cacheKey = `user_can_send_${payload.userId}`; const canSend = await getCachedSystemStat2(db, cacheKey, async (db2) => { const { results } = await db2.prepare("SELECT can_send FROM users WHERE id = ?").bind(payload.userId).all(); return results?.[0]?.can_send ? 1 : 0; }); return canSend === 1; } return false; } __name(checkSendPermission, "checkSendPermission"); if (path === "/api/send" && request.method === "POST") { if (isMock) return new Response("\u6F14\u793A\u6A21\u5F0F\u4E0D\u53EF\u53D1\u9001", { status: 403 }); try { if (!RESEND_API_KEY) return new Response("\u672A\u914D\u7F6E Resend API Key", { status: 500 }); const allowed = await checkSendPermission(); if (!allowed) return new Response("\u672A\u6388\u6743\u53D1\u4EF6\u6216\u8BE5\u7528\u6237\u672A\u88AB\u6388\u4E88\u53D1\u4EF6\u6743\u9650", { status: 403 }); const sendPayload = await request.json(); const result = await sendEmailWithAutoResend(RESEND_API_KEY, sendPayload); await recordSentEmail(db, { resendId: result.id || null, fromName: sendPayload.fromName || null, from: sendPayload.from, to: sendPayload.to, subject: sendPayload.subject, html: sendPayload.html, text: sendPayload.text, status: "delivered", scheduledAt: sendPayload.scheduledAt || null }); return Response.json({ success: true, id: result.id }); } catch (e) { return new Response("\u53D1\u9001\u5931\u8D25: " + e.message, { status: 500 }); } } if (path === "/api/send/batch" && request.method === "POST") { if (isMock) return new Response("\u6F14\u793A\u6A21\u5F0F\u4E0D\u53EF\u53D1\u9001", { status: 403 }); try { if (!RESEND_API_KEY) return new Response("\u672A\u914D\u7F6E Resend API Key", { status: 500 }); const allowed = await checkSendPermission(); if (!allowed) return new Response("\u672A\u6388\u6743\u53D1\u4EF6\u6216\u8BE5\u7528\u6237\u672A\u88AB\u6388\u4E88\u53D1\u4EF6\u6743\u9650", { status: 403 }); const items = await request.json(); const result = await sendBatchWithAutoResend(RESEND_API_KEY, items); try { const arr = Array.isArray(result) ? result : []; for (let i = 0; i < arr.length; i++) { const id = arr[i]?.id; const payload = items[i] || {}; await recordSentEmail(db, { resendId: id || null, fromName: payload.fromName || null, from: payload.from, to: payload.to, subject: payload.subject, html: payload.html, text: payload.text, status: "delivered", scheduledAt: payload.scheduledAt || null }); } } catch (_) { } return Response.json({ success: true, result }); } catch (e) { return new Response("\u6279\u91CF\u53D1\u9001\u5931\u8D25: " + e.message, { status: 500 }); } } if (path.startsWith("/api/send/") && request.method === "GET") { if (isMock) return new Response("\u6F14\u793A\u6A21\u5F0F\u4E0D\u53EF\u67E5\u8BE2\u771F\u5B9E\u53D1\u9001", { status: 403 }); const id = path.split("/")[3]; try { if (!RESEND_API_KEY) return new Response("\u672A\u914D\u7F6E Resend API Key", { status: 500 }); const data = await getEmailFromResend(RESEND_API_KEY, id); return Response.json(data); } catch (e) { return new Response("\u67E5\u8BE2\u5931\u8D25: " + e.message, { status: 500 }); } } if (path.startsWith("/api/send/") && request.method === "PATCH") { if (isMock) return new Response("\u6F14\u793A\u6A21\u5F0F\u4E0D\u53EF\u64CD\u4F5C", { status: 403 }); const id = path.split("/")[3]; try { if (!RESEND_API_KEY) return new Response("\u672A\u914D\u7F6E Resend API Key", { status: 500 }); const body = await request.json(); let data = { ok: true }; if (body && typeof body.status === "string") { await updateSentEmail(db, id, { status: body.status }); } if (body && body.scheduledAt) { data = await updateEmailInResend(RESEND_API_KEY, { id, scheduledAt: body.scheduledAt }); await updateSentEmail(db, id, { scheduled_at: body.scheduledAt }); } return Response.json(data || { ok: true }); } catch (e) { return new Response("\u66F4\u65B0\u5931\u8D25: " + e.message, { status: 500 }); } } if (path.startsWith("/api/send/") && path.endsWith("/cancel") && request.method === "POST") { if (isMock) return new Response("\u6F14\u793A\u6A21\u5F0F\u4E0D\u53EF\u64CD\u4F5C", { status: 403 }); const id = path.split("/")[3]; try { if (!RESEND_API_KEY) return new Response("\u672A\u914D\u7F6E Resend API Key", { status: 500 }); const data = await cancelEmailInResend(RESEND_API_KEY, id); await updateSentEmail(db, id, { status: "canceled" }); return Response.json(data); } catch (e) { return new Response("\u53D6\u6D88\u5931\u8D25: " + e.message, { status: 500 }); } } if (request.method === "DELETE" && path.startsWith("/api/sent/")) { if (isMock) return new Response("\u6F14\u793A\u6A21\u5F0F\u4E0D\u53EF\u64CD\u4F5C", { status: 403 }); const id = path.split("/")[3]; try { await db.prepare("DELETE FROM sent_emails WHERE id = ?").bind(id).run(); return Response.json({ success: true }); } catch (e) { return new Response("\u5220\u9664\u53D1\u4EF6\u8BB0\u5F55\u5931\u8D25: " + e.message, { status: 500 }); } } if (path === "/api/emails" && request.method === "GET") { const mailbox = url.searchParams.get("mailbox"); if (!mailbox) { return new Response("\u7F3A\u5C11 mailbox \u53C2\u6570", { status: 400 }); } try { if (isMock) { return Response.json(buildMockEmails(6)); } const normalized = extractEmail(mailbox).trim().toLowerCase(); const mailboxId = await getMailboxIdByAddress(db, normalized); if (!mailboxId) return Response.json([]); let timeFilter = ""; let timeParam = []; if (isMailboxOnly) { const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1e3).toISOString(); timeFilter = " AND received_at >= ?"; timeParam = [twentyFourHoursAgo]; } const limit = Math.min(parseInt(url.searchParams.get("limit") || "20", 10), 50); try { const { results } = await db.prepare(` SELECT id, sender, subject, received_at, is_read, preview, verification_code FROM messages WHERE mailbox_id = ?${timeFilter} ORDER BY received_at DESC LIMIT ? `).bind(mailboxId, ...timeParam, limit).all(); return Response.json(results); } catch (e) { const { results } = await db.prepare(` SELECT id, sender, subject, received_at, is_read, CASE WHEN content IS NOT NULL AND content <> '' THEN SUBSTR(content, 1, 120) ELSE SUBSTR(COALESCE(html_content, ''), 1, 120) END AS preview FROM messages WHERE mailbox_id = ?${timeFilter} ORDER BY received_at DESC LIMIT ? `).bind(mailboxId, ...timeParam, limit).all(); return Response.json(results); } } catch (e) { console.error("\u67E5\u8BE2\u90AE\u4EF6\u5931\u8D25:", e); return new Response("\u67E5\u8BE2\u90AE\u4EF6\u5931\u8D25", { status: 500 }); } } if (path === "/api/emails/batch" && request.method === "GET") { try { const idsParam = String(url.searchParams.get("ids") || "").trim(); if (!idsParam) return Response.json([]); const ids = idsParam.split(",").map((s) => parseInt(s, 10)).filter((n) => Number.isInteger(n) && n > 0); if (!ids.length) return Response.json([]); if (ids.length > 50) { return new Response("\u5355\u6B21\u6700\u591A\u67E5\u8BE250\u5C01\u90AE\u4EF6", { status: 400 }); } if (isMock) { const arr = ids.map((id) => buildMockEmailDetail(id)); return Response.json(arr); } let timeFilter = ""; let timeParam = []; if (isMailboxOnly) { const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1e3).toISOString(); timeFilter = " AND received_at >= ?"; timeParam = [twentyFourHoursAgo]; } const placeholders = ids.map(() => "?").join(","); try { const { results } = await db.prepare(` SELECT id, sender, to_addrs, subject, verification_code, preview, r2_bucket, r2_object_key, received_at, is_read FROM messages WHERE id IN (${placeholders})${timeFilter} `).bind(...ids, ...timeParam).all(); return Response.json(results || []); } catch (e) { const { results } = await db.prepare(` SELECT id, sender, subject, content, html_content, received_at, is_read FROM messages WHERE id IN (${placeholders})${timeFilter} `).bind(...ids, ...timeParam).all(); return Response.json(results || []); } } catch (e) { return new Response("\u6279\u91CF\u67E5\u8BE2\u5931\u8D25", { status: 500 }); } } if (path === "/api/mailboxes" && request.method === "GET") { const limit = Math.min(parseInt(url.searchParams.get("limit") || "10", 10), 50); const offset = Math.max(parseInt(url.searchParams.get("offset") || "0", 10), 0); const q = String(url.searchParams.get("q") || "").trim().toLowerCase(); const domain = String(url.searchParams.get("domain") || "").trim().toLowerCase(); const canLoginParam = String(url.searchParams.get("can_login") || "").trim(); if (isMock) { return Response.json(buildMockMailboxes(limit, offset, mailDomains)); } try { if (isStrictAdmin()) { const payload2 = getJwtPayload(); const adminUid = Number(payload2?.userId || 0); const like2 = `%${q.replace(/%/g, "").replace(/_/g, "")}%`; let whereConditions2 = []; let bindParams2 = [adminUid || 0]; if (q) { whereConditions2.push("LOWER(m.address) LIKE LOWER(?)"); bindParams2.push(like2); } if (domain) { whereConditions2.push("LOWER(m.address) LIKE LOWER(?)"); bindParams2.push(`%@${domain}`); } if (canLoginParam === "true") { whereConditions2.push("m.can_login = 1"); } else if (canLoginParam === "false") { whereConditions2.push("m.can_login = 0"); } const whereClause2 = whereConditions2.length > 0 ? "WHERE " + whereConditions2.join(" AND ") : ""; bindParams2.push(limit, offset); const { results: results2 } = await db.prepare(` SELECT m.address, m.created_at, COALESCE(um.is_pinned, 0) AS is_pinned, CASE WHEN (m.password_hash IS NULL OR m.password_hash = '') THEN 1 ELSE 0 END AS password_is_default, COALESCE(m.can_login, 0) AS can_login FROM mailboxes m LEFT JOIN user_mailboxes um ON um.mailbox_id = m.id AND um.user_id = ? ${whereClause2} ORDER BY is_pinned DESC, m.created_at DESC LIMIT ? OFFSET ? `).bind(...bindParams2).all(); return Response.json(results2 || []); } const payload = getJwtPayload(); const uid = Number(payload?.userId || 0); if (!uid) return Response.json([]); const like = `%${q.replace(/%/g, "").replace(/_/g, "")}%`; let whereConditions = ["um.user_id = ?"]; let bindParams = [uid]; if (q) { whereConditions.push("LOWER(m.address) LIKE LOWER(?)"); bindParams.push(like); } if (domain) { whereConditions.push("LOWER(m.address) LIKE LOWER(?)"); bindParams.push(`%@${domain}`); } if (canLoginParam === "true") { whereConditions.push("m.can_login = 1"); } else if (canLoginParam === "false") { whereConditions.push("m.can_login = 0"); } const whereClause = "WHERE " + whereConditions.join(" AND "); bindParams.push(limit, offset); const { results } = await db.prepare(` SELECT m.address, m.created_at, um.is_pinned, CASE WHEN (m.password_hash IS NULL OR m.password_hash = '') THEN 1 ELSE 0 END AS password_is_default, COALESCE(m.can_login, 0) AS can_login FROM user_mailboxes um JOIN mailboxes m ON m.id = um.mailbox_id ${whereClause} ORDER BY um.is_pinned DESC, m.created_at DESC LIMIT ? OFFSET ? `).bind(...bindParams).all(); return Response.json(results || []); } catch (_) { return Response.json([]); } } if (path === "/api/mailboxes/reset-password" && request.method === "POST") { if (isMock) return Response.json({ success: true, mock: true }); try { if (!isStrictAdmin()) return new Response("Forbidden", { status: 403 }); const address = String(url.searchParams.get("address") || "").trim().toLowerCase(); if (!address) return new Response("\u7F3A\u5C11 address \u53C2\u6570", { status: 400 }); await db.prepare("UPDATE mailboxes SET password_hash = NULL WHERE address = ?").bind(address).run(); return Response.json({ success: true }); } catch (e) { return new Response("\u91CD\u7F6E\u5931\u8D25", { status: 500 }); } } if (path === "/api/mailboxes/pin" && request.method === "POST") { if (isMock) return new Response("\u6F14\u793A\u6A21\u5F0F\u4E0D\u53EF\u64CD\u4F5C", { status: 403 }); const address = url.searchParams.get("address"); if (!address) return new Response("\u7F3A\u5C11 address \u53C2\u6570", { status: 400 }); const payload = getJwtPayload(); let uid = Number(payload?.userId || 0); if (!uid && isStrictAdmin()) { try { const { results } = await db.prepare("SELECT id FROM users WHERE username = ?").bind(String(options?.adminName || "admin").toLowerCase()).all(); if (results && results.length) { uid = Number(results[0].id); } else { const uname = String(options?.adminName || "admin").toLowerCase(); await db.prepare("INSERT INTO users (username, role, can_send, mailbox_limit) VALUES (?, 'admin', 1, 9999)").bind(uname).run(); const again = await db.prepare("SELECT id FROM users WHERE username = ?").bind(uname).all(); uid = Number(again?.results?.[0]?.id || 0); } } catch (_) { uid = 0; } } if (!uid) return new Response("\u672A\u767B\u5F55", { status: 401 }); try { const result = await toggleMailboxPin(db, address, uid); return Response.json({ success: true, ...result }); } catch (e) { return new Response("\u64CD\u4F5C\u5931\u8D25: " + e.message, { status: 500 }); } } if (path === "/api/mailboxes/toggle-login" && request.method === "POST") { if (isMock) return new Response("\u6F14\u793A\u6A21\u5F0F\u4E0D\u53EF\u64CD\u4F5C", { status: 403 }); if (!isStrictAdmin()) return new Response("Forbidden", { status: 403 }); try { const body = await request.json(); const address = String(body.address || "").trim().toLowerCase(); const canLogin = Boolean(body.can_login); if (!address) return new Response("\u7F3A\u5C11 address \u53C2\u6570", { status: 400 }); const mbRes = await db.prepare("SELECT id FROM mailboxes WHERE address = ?").bind(address).all(); if (!mbRes.results || mbRes.results.length === 0) { return new Response("\u90AE\u7BB1\u4E0D\u5B58\u5728", { status: 404 }); } await db.prepare("UPDATE mailboxes SET can_login = ? WHERE address = ?").bind(canLogin ? 1 : 0, address).run(); return Response.json({ success: true, can_login: canLogin }); } catch (e) { return new Response("\u64CD\u4F5C\u5931\u8D25: " + e.message, { status: 500 }); } } if (path === "/api/mailboxes/change-password" && request.method === "POST") { if (isMock) return new Response("\u6F14\u793A\u6A21\u5F0F\u4E0D\u53EF\u64CD\u4F5C", { status: 403 }); if (!isStrictAdmin()) return new Response("Forbidden", { status: 403 }); try { const body = await request.json(); const address = String(body.address || "").trim().toLowerCase(); const newPassword = String(body.new_password || "").trim(); if (!address) return new Response("\u7F3A\u5C11 address \u53C2\u6570", { status: 400 }); if (!newPassword || newPassword.length < 6) return new Response("\u5BC6\u7801\u957F\u5EA6\u81F3\u5C116\u4F4D", { status: 400 }); const mbRes = await db.prepare("SELECT id FROM mailboxes WHERE address = ?").bind(address).all(); if (!mbRes.results || mbRes.results.length === 0) { return new Response("\u90AE\u7BB1\u4E0D\u5B58\u5728", { status: 404 }); } const newPasswordHash = await sha256Hex3(newPassword); await db.prepare("UPDATE mailboxes SET password_hash = ? WHERE address = ?").bind(newPasswordHash, address).run(); return Response.json({ success: true }); } catch (e) { return new Response("\u64CD\u4F5C\u5931\u8D25: " + e.message, { status: 500 }); } } if (path === "/api/mailboxes/batch-toggle-login" && request.method === "POST") { if (isMock) return new Response("\u6F14\u793A\u6A21\u5F0F\u4E0D\u53EF\u64CD\u4F5C", { status: 403 }); if (!isStrictAdmin()) return new Response("Forbidden", { status: 403 }); try { const body = await request.json(); const addresses = body.addresses || []; const canLogin = Boolean(body.can_login); if (!Array.isArray(addresses) || addresses.length === 0) { return new Response("\u7F3A\u5C11 addresses \u53C2\u6570\u6216\u5730\u5740\u5217\u8868\u4E3A\u7A7A", { status: 400 }); } if (addresses.length > 100) { return new Response("\u5355\u6B21\u6700\u591A\u5904\u7406100\u4E2A\u90AE\u7BB1", { status: 400 }); } let successCount = 0; let failCount = 0; const results = []; const addressMap = new Map(); for (const address of addresses) { const normalizedAddress = String(address || "").trim().toLowerCase(); if (!normalizedAddress) { failCount++; results.push({ address, success: false, error: "\u5730\u5740\u4E3A\u7A7A" }); continue; } addressMap.set(normalizedAddress, address); } let existingMailboxes = new Set(); if (addressMap.size > 0) { try { const addressList = Array.from(addressMap.keys()); const placeholders = addressList.map(() => "?").join(","); const checkResult = await db.prepare( `SELECT address FROM mailboxes WHERE address IN (${placeholders})` ).bind(...addressList).all(); for (const row of checkResult.results || []) { existingMailboxes.add(row.address); } } catch (e) { console.error("\u6279\u91CF\u68C0\u67E5\u90AE\u7BB1\u5931\u8D25:", e); } } const batchStatements = []; for (const [normalizedAddress, originalAddress] of addressMap.entries()) { if (existingMailboxes.has(normalizedAddress)) { batchStatements.push({ stmt: db.prepare("UPDATE mailboxes SET can_login = ? WHERE address = ?").bind(canLogin ? 1 : 0, normalizedAddress), address: normalizedAddress, type: "update" }); } else { batchStatements.push({ stmt: db.prepare("INSERT INTO mailboxes (address, can_login) VALUES (?, ?)").bind(normalizedAddress, canLogin ? 1 : 0), address: normalizedAddress, type: "insert" }); } } if (batchStatements.length > 0) { try { const batchResults = await db.batch(batchStatements.map((s) => s.stmt)); for (let i = 0; i < batchResults.length; i++) { const result = batchResults[i]; const operation = batchStatements[i]; if (result.success !== false) { successCount++; results.push({ address: operation.address, success: true, [operation.type === "insert" ? "created" : "updated"]: true }); } else { failCount++; results.push({ address: operation.address, success: false, error: result.error || "\u64CD\u4F5C\u5931\u8D25" }); } } } catch (e) { console.error("\u6279\u91CF\u64CD\u4F5C\u6267\u884C\u5931\u8D25:", e); return new Response("\u6279\u91CF\u64CD\u4F5C\u5931\u8D25: " + e.message, { status: 500 }); } } return Response.json({ success: true, success_count: successCount, fail_count: failCount, total: addresses.length, results }); } catch (e) { return new Response("\u64CD\u4F5C\u5931\u8D25: " + e.message, { status: 500 }); } } if (path === "/api/mailboxes" && request.method === "DELETE") { if (isMock) return new Response("\u6F14\u793A\u6A21\u5F0F\u4E0D\u53EF\u5220\u9664", { status: 403 }); const raw = url.searchParams.get("address"); if (!raw) return new Response("\u7F3A\u5C11 address \u53C2\u6570", { status: 400 }); const normalized = String(raw || "").trim().toLowerCase(); try { const { invalidateMailboxCache: invalidateMailboxCache2 } = await Promise.resolve().then(() => (init_cacheHelper(), cacheHelper_exports)); const mailboxId = await getMailboxIdByAddress(db, normalized); if (!mailboxId) return new Response(JSON.stringify({ success: false, message: "\u90AE\u7BB1\u4E0D\u5B58\u5728" }), { status: 404 }); if (!isStrictAdmin()) { const payload = getJwtPayload(); if (!payload || payload.role !== "admin" || !payload.userId) return new Response("Forbidden", { status: 403 }); const own = await db.prepare("SELECT 1 FROM user_mailboxes WHERE user_id = ? AND mailbox_id = ? LIMIT 1").bind(Number(payload.userId), mailboxId).all(); if (!own?.results?.length) return new Response("Forbidden", { status: 403 }); } try { await db.exec("BEGIN"); } catch (_) { } await db.prepare("DELETE FROM messages WHERE mailbox_id = ?").bind(mailboxId).run(); const deleteResult = await db.prepare("DELETE FROM mailboxes WHERE id = ?").bind(mailboxId).run(); try { await db.exec("COMMIT"); } catch (_) { } const deleted = (deleteResult?.meta?.changes || 0) > 0; if (deleted) { invalidateMailboxCache2(normalized); const { invalidateSystemStatCache: invalidateSystemStatCache2 } = await Promise.resolve().then(() => (init_cacheHelper(), cacheHelper_exports)); invalidateSystemStatCache2("total_mailboxes"); } return Response.json({ success: deleted, deleted }); } catch (e) { try { await db.exec("ROLLBACK"); } catch (_) { } return new Response("\u5220\u9664\u5931\u8D25", { status: 500 }); } } if (request.method === "GET" && path.startsWith("/api/email/") && path.endsWith("/download")) { if (options.mockOnly) return new Response("\u6F14\u793A\u6A21\u5F0F\u4E0D\u53EF\u4E0B\u8F7D", { status: 403 }); const id = path.split("/")[3]; const { results } = await db.prepare("SELECT r2_bucket, r2_object_key FROM messages WHERE id = ?").bind(id).all(); const row = (results || [])[0]; if (!row || !row.r2_object_key) return new Response("\u672A\u627E\u5230\u5BF9\u8C61", { status: 404 }); try { const r2 = options.r2; if (!r2) return new Response("R2 \u672A\u7ED1\u5B9A", { status: 500 }); const obj = await r2.get(row.r2_object_key); if (!obj) return new Response("\u5BF9\u8C61\u4E0D\u5B58\u5728", { status: 404 }); const headers = new Headers({ "Content-Type": "message/rfc822" }); headers.set("Content-Disposition", `attachment; filename="${String(row.r2_object_key).split("/").pop()}"`); return new Response(obj.body, { headers }); } catch (e) { return new Response("\u4E0B\u8F7D\u5931\u8D25", { status: 500 }); } } if (request.method === "GET" && path.startsWith("/api/email/")) { const emailId = path.split("/")[3]; if (isMock) { return Response.json(buildMockEmailDetail(emailId)); } try { let timeFilter = ""; let timeParam = []; if (isMailboxOnly) { const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1e3).toISOString(); timeFilter = " AND received_at >= ?"; timeParam = [twentyFourHoursAgo]; } const { results } = await db.prepare(` SELECT id, sender, to_addrs, subject, verification_code, preview, r2_bucket, r2_object_key, received_at, is_read FROM messages WHERE id = ?${timeFilter} `).bind(emailId, ...timeParam).all(); if (results.length === 0) { if (isMailboxOnly) { return new Response("\u90AE\u4EF6\u4E0D\u5B58\u5728\u6216\u5DF2\u8D85\u8FC724\u5C0F\u65F6\u8BBF\u95EE\u671F\u9650", { status: 404 }); } return new Response("\u672A\u627E\u5230\u90AE\u4EF6", { status: 404 }); } await db.prepare(`UPDATE messages SET is_read = 1 WHERE id = ?`).bind(emailId).run(); const row = results[0]; let content = ""; let html_content = ""; try { if (row.r2_object_key && options.r2) { const obj = await options.r2.get(row.r2_object_key); if (obj) { let raw = ""; if (typeof obj.text === "function") raw = await obj.text(); else if (typeof obj.arrayBuffer === "function") raw = await new Response(await obj.arrayBuffer()).text(); else raw = await new Response(obj.body).text(); const parsed = parseEmailBody(raw || ""); content = parsed.text || ""; html_content = parsed.html || ""; } } } catch (_) { } if (!content && !html_content) { try { const fallback = await db.prepare("SELECT content, html_content FROM messages WHERE id = ?").bind(emailId).all(); const fr = (fallback?.results || [])[0] || {}; content = content || fr.content || ""; html_content = html_content || fr.html_content || ""; } catch (_) { } } return Response.json({ ...row, content, html_content, download: row.r2_object_key ? `/api/email/${emailId}/download` : "" }); } catch (e) { const { results } = await db.prepare(` SELECT id, sender, subject, content, html_content, received_at, is_read FROM messages WHERE id = ? `).bind(emailId).all(); if (!results || !results.length) return new Response("\u672A\u627E\u5230\u90AE\u4EF6", { status: 404 }); await db.prepare(`UPDATE messages SET is_read = 1 WHERE id = ?`).bind(emailId).run(); return Response.json(results[0]); } } if (request.method === "DELETE" && path.startsWith("/api/email/")) { if (isMock) return new Response("\u6F14\u793A\u6A21\u5F0F\u4E0D\u53EF\u5220\u9664", { status: 403 }); const emailId = path.split("/")[3]; if (!emailId || !Number.isInteger(parseInt(emailId))) { return new Response("\u65E0\u6548\u7684\u90AE\u4EF6ID", { status: 400 }); } try { const result = await db.prepare(`DELETE FROM messages WHERE id = ?`).bind(emailId).run(); const deleted = (result?.meta?.changes || 0) > 0; return Response.json({ success: true, deleted, message: deleted ? "\u90AE\u4EF6\u5DF2\u5220\u9664" : "\u90AE\u4EF6\u4E0D\u5B58\u5728\u6216\u5DF2\u88AB\u5220\u9664" }); } catch (e) { console.error("\u5220\u9664\u90AE\u4EF6\u5931\u8D25:", e); return new Response("\u5220\u9664\u90AE\u4EF6\u65F6\u53D1\u751F\u9519\u8BEF: " + e.message, { status: 500 }); } } if (request.method === "DELETE" && path === "/api/emails") { if (isMock) return new Response("\u6F14\u793A\u6A21\u5F0F\u4E0D\u53EF\u6E05\u7A7A", { status: 403 }); const mailbox = url.searchParams.get("mailbox"); if (!mailbox) { return new Response("\u7F3A\u5C11 mailbox \u53C2\u6570", { status: 400 }); } try { const normalized = extractEmail(mailbox).trim().toLowerCase(); const mailboxId = await getMailboxIdByAddress(db, normalized); if (!mailboxId) { return Response.json({ success: true, deletedCount: 0 }); } const result = await db.prepare(`DELETE FROM messages WHERE mailbox_id = ?`).bind(mailboxId).run(); const deletedCount = result?.meta?.changes || 0; return Response.json({ success: true, deletedCount }); } catch (e) { console.error("\u6E05\u7A7A\u90AE\u4EF6\u5931\u8D25:", e); return new Response("\u6E05\u7A7A\u90AE\u4EF6\u5931\u8D25", { status: 500 }); } } if (path === "/api/mailbox/password" && request.method === "PUT") { if (isMock) return new Response("\u6F14\u793A\u6A21\u5F0F\u4E0D\u53EF\u4FEE\u6539\u5BC6\u7801", { status: 403 }); try { const body = await request.json(); const { currentPassword, newPassword } = body; if (!currentPassword || !newPassword) { return new Response("\u5F53\u524D\u5BC6\u7801\u548C\u65B0\u5BC6\u7801\u4E0D\u80FD\u4E3A\u7A7A", { status: 400 }); } if (newPassword.length < 6) { return new Response("\u65B0\u5BC6\u7801\u957F\u5EA6\u81F3\u5C116\u4F4D", { status: 400 }); } const payload = getJwtPayload(); const mailboxAddress = payload?.mailboxAddress; const mailboxId = payload?.mailboxId; if (!mailboxAddress || !mailboxId) { return new Response("\u672A\u627E\u5230\u90AE\u7BB1\u4FE1\u606F", { status: 401 }); } const { results } = await db.prepare("SELECT password_hash FROM mailboxes WHERE id = ? AND address = ?").bind(mailboxId, mailboxAddress).all(); if (!results || results.length === 0) { return new Response("\u90AE\u7BB1\u4E0D\u5B58\u5728", { status: 404 }); } const mailbox = results[0]; let currentPasswordValid = false; if (mailbox.password_hash) { const { verifyPassword: verifyPassword3 } = await Promise.resolve().then(() => (init_authentication(), authentication_exports)); currentPasswordValid = await verifyPassword3(currentPassword, mailbox.password_hash); } else { currentPasswordValid = currentPassword === mailboxAddress; } if (!currentPasswordValid) { return new Response("\u5F53\u524D\u5BC6\u7801\u9519\u8BEF", { status: 400 }); } const { hashPassword: hashPassword2 } = await Promise.resolve().then(() => (init_authentication(), authentication_exports)); const newPasswordHash = await hashPassword2(newPassword); await db.prepare("UPDATE mailboxes SET password_hash = ? WHERE id = ?").bind(newPasswordHash, mailboxId).run(); return Response.json({ success: true, message: "\u5BC6\u7801\u4FEE\u6539\u6210\u529F" }); } catch (error) { console.error("\u4FEE\u6539\u5BC6\u7801\u5931\u8D25:", error); return new Response("\u4FEE\u6539\u5BC6\u7801\u5931\u8D25", { status: 500 }); } } return new Response("\u672A\u627E\u5230 API \u8DEF\u5F84", { status: 404 }); } __name(handleApiRequest, "handleApiRequest"); async function handleEmailReceive(request, db, env) { try { const emailData = await request.json(); const to = String(emailData?.to || ""); const from = String(emailData?.from || ""); const subject = String(emailData?.subject || "(\u65E0\u4E3B\u9898)"); const text = String(emailData?.text || ""); const html = String(emailData?.html || ""); const mailbox = extractEmail(to); const sender = extractEmail(from); const mailboxId = await getOrCreateMailboxId(db, mailbox); const now = new Date(); const dateStr = now.toUTCString(); const boundary = "mf-" + (crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2)); let eml = ""; if (html) { eml = [ `From: <${sender}>`, `To: <${mailbox}>`, `Subject: ${subject}`, `Date: ${dateStr}`, "MIME-Version: 1.0", `Content-Type: multipart/alternative; boundary="${boundary}"`, "", `--${boundary}`, 'Content-Type: text/plain; charset="utf-8"', "Content-Transfer-Encoding: 8bit", "", text || "", `--${boundary}`, 'Content-Type: text/html; charset="utf-8"', "Content-Transfer-Encoding: 8bit", "", html, `--${boundary}--`, "" ].join("\r\n"); } else { eml = [ `From: <${sender}>`, `To: <${mailbox}>`, `Subject: ${subject}`, `Date: ${dateStr}`, "MIME-Version: 1.0", 'Content-Type: text/plain; charset="utf-8"', "Content-Transfer-Encoding: 8bit", "", text || "", "" ].join("\r\n"); } let objectKey = ""; try { const r2 = env?.MAIL_EML; if (r2) { const y = now.getUTCFullYear(); const m = String(now.getUTCMonth() + 1).padStart(2, "0"); const d = String(now.getUTCDate()).padStart(2, "0"); const hh = String(now.getUTCHours()).padStart(2, "0"); const mm = String(now.getUTCMinutes()).padStart(2, "0"); const ss = String(now.getUTCSeconds()).padStart(2, "0"); const keyId = crypto.randomUUID ? crypto.randomUUID() : `${Date.now()}-${Math.random().toString(36).slice(2)}`; const safeMailbox = (mailbox || "unknown").toLowerCase().replace(/[^a-z0-9@._-]/g, "_"); objectKey = `${y}/${m}/${d}/${safeMailbox}/${hh}${mm}${ss}-${keyId}.eml`; await r2.put(objectKey, eml, { httpMetadata: { contentType: "message/rfc822" } }); } } catch (_) { objectKey = ""; } const previewBase = (text || html.replace(/<[^>]+>/g, " ")).replace(/\s+/g, " ").trim(); const preview = String(previewBase || "").slice(0, 120); let verificationCode = ""; try { verificationCode = extractVerificationCode({ subject, text, html }); } catch (_) { } await db.prepare(` INSERT INTO messages (mailbox_id, sender, to_addrs, subject, verification_code, preview, r2_bucket, r2_object_key) VALUES (?, ?, ?, ?, ?, ?, ?, ?) `).bind( mailboxId, sender, String(to || ""), subject || "(\u65E0\u4E3B\u9898)", verificationCode || null, preview || null, "mail-eml", objectKey || "" ).run(); return Response.json({ success: true }); } catch (error) { console.error("\u5904\u7406\u90AE\u4EF6\u65F6\u51FA\u9519:", error); return new Response("\u5904\u7406\u90AE\u4EF6\u5931\u8D25", { status: 500 }); } } __name(handleEmailReceive, "handleEmailReceive"); function forwardByLocalPart(message, localPart, ctx, env) { const rules = parseForwardRules(env?.FORWARD_RULES); const target = resolveTargetEmail(localPart, rules); if (!target) return; try { ctx.waitUntil(message.forward(target)); } catch (e) { console.error("Forward error:", e); } } __name(forwardByLocalPart, "forwardByLocalPart"); function parseForwardRules(rulesRaw) { if (rulesRaw === void 0 || rulesRaw === null) { return []; } const trimmed = String(rulesRaw).trim(); if (trimmed === "" || trimmed === "[]" || trimmed.toLowerCase() === "disabled" || trimmed.toLowerCase() === "none") { return []; } try { const parsed = JSON.parse(trimmed); if (Array.isArray(parsed)) { return normalizeRules(parsed); } } catch (_) { } const rules = []; for (const pair of trimmed.split(",")) { const [prefix, email] = pair.split("=").map((s) => (s || "").trim()); if (!prefix || !email) continue; rules.push({ prefix, email }); } return normalizeRules(rules); } __name(parseForwardRules, "parseForwardRules"); function normalizeRules(items) { const result = []; for (const it of items) { const prefix = String(it.prefix || "").toLowerCase(); const email = String(it.email || "").trim(); if (!prefix || !email) continue; result.push({ prefix, email }); } return result; } __name(normalizeRules, "normalizeRules"); function resolveTargetEmail(localPart, rules) { const lp = String(localPart || "").toLowerCase(); for (const r of rules) { if (r.prefix === "*") continue; if (lp.startsWith(r.prefix)) return r.email; } const wildcard = rules.find((r) => r.prefix === "*"); return wildcard ? wildcard.email : null; } __name(resolveTargetEmail, "resolveTargetEmail"); init_authentication(); var _cachedDB = null; var _cachedBindingName = null; function getDatabase(env) { if (_cachedDB && _cachedBindingName && env[_cachedBindingName]) { return _cachedDB; } const possibleBindings = [ "TEMP_MAIL_DB", "DB", "DATABASE", "D1_DB", "MAIL_DB", "MAILFREE_DB", "TEMPMAIL_DB" ]; for (const bindingName of possibleBindings) { if (env[bindingName]) { if (_cachedBindingName !== bindingName) { console.log(`\u4F7F\u7528\u6570\u636E\u5E93\u7ED1\u5B9A: ${bindingName}`); _cachedBindingName = bindingName; } _cachedDB = env[bindingName]; return _cachedDB; } } const envKeys = Object.keys(env); for (const key of envKeys) { const value = env[key]; if (value && typeof value === "object" && typeof value.prepare === "function") { if (_cachedBindingName !== key) { console.log(`\u81EA\u52A8\u68C0\u6D4B\u5230\u6570\u636E\u5E93\u7ED1\u5B9A: ${key}`); _cachedBindingName = key; } _cachedDB = value; return _cachedDB; } } console.error("\u672A\u627E\u5230\u6709\u6548\u7684D1\u6570\u636E\u5E93\u7ED1\u5B9A\uFF0C\u8BF7\u68C0\u67E5wrangler.toml\u914D\u7F6E"); return null; } __name(getDatabase, "getDatabase"); async function validateDatabaseConnection(db) { if (!db) return false; try { await db.prepare("SELECT 1").all(); return true; } catch (error) { console.error("\u6570\u636E\u5E93\u8FDE\u63A5\u9A8C\u8BC1\u5931\u8D25:", error); return false; } } __name(validateDatabaseConnection, "validateDatabaseConnection"); var _validationCache = new Map(); async function getDatabaseWithValidation(env) { const db = getDatabase(env); if (!db) { throw new Error("\u65E0\u6CD5\u83B7\u53D6\u6570\u636E\u5E93\u8FDE\u63A5\uFF0C\u8BF7\u68C0\u67E5wrangler.toml\u4E2D\u7684D1\u6570\u636E\u5E93\u914D\u7F6E"); } const cacheKey = _cachedBindingName || "unknown"; if (_validationCache.has(cacheKey)) { const cached = _validationCache.get(cacheKey); if (Date.now() - cached.timestamp < 5 * 60 * 1e3) { return cached.valid ? db : (() => { throw new Error("\u6570\u636E\u5E93\u8FDE\u63A5\u65E0\u6548\uFF08\u7F13\u5B58\uFF09"); })(); } } const isValid = await validateDatabaseConnection(db); _validationCache.set(cacheKey, { valid: isValid, timestamp: Date.now() }); if (!isValid) { throw new Error("\u6570\u636E\u5E93\u8FDE\u63A5\u65E0\u6548\uFF0C\u8BF7\u68C0\u67E5\u6570\u636E\u5E93\u914D\u7F6E\u548C\u6743\u9650"); } return db; } __name(getDatabaseWithValidation, "getDatabaseWithValidation"); var Router = class { static { __name(this, "Router"); } constructor() { this.routes = []; this.middlewares = []; } use(middleware) { this.middlewares.push(middleware); } get(path, handler) { this.addRoute("GET", path, handler); } post(path, handler) { this.addRoute("POST", path, handler); } patch(path, handler) { this.addRoute("PATCH", path, handler); } put(path, handler) { this.addRoute("PUT", path, handler); } delete(path, handler) { this.addRoute("DELETE", path, handler); } addRoute(method, path, handler) { const paramNames = []; const regexPath = path.replace(/:\w+/g, (match) => { paramNames.push(match.slice(1)); return "([^/]+)"; }).replace(/\*/g, ".*"); this.routes.push({ method: method.toUpperCase(), path, regex: new RegExp(`^${regexPath}$`), paramNames, handler }); } async handle(request, context) { const url = new URL(request.url); const method = request.method.toUpperCase(); const pathname = url.pathname; for (const route of this.routes) { if (route.method === method) { const match = pathname.match(route.regex); if (match) { const params = {}; route.paramNames.forEach((name, index) => { params[name] = match[index + 1]; }); const enhancedContext = { ...context, params, query: Object.fromEntries(url.searchParams.entries()), request, url }; for (const middleware of this.middlewares) { const result = await middleware(enhancedContext); if (result) return result; } return await route.handler(enhancedContext); } } } return null; } }; async function sha256Hex2(text) { const enc = new TextEncoder(); const data = enc.encode(String(text || "")); const digest = await crypto.subtle.digest("SHA-256", data); const bytes = new Uint8Array(digest); let out = ""; for (let i = 0; i < bytes.length; i++) { out += bytes[i].toString(16).padStart(2, "0"); } return out; } __name(sha256Hex2, "sha256Hex"); async function verifyPassword2(rawPassword, hashed) { if (!hashed) return false; try { const hex = (await sha256Hex2(rawPassword)).toLowerCase(); return hex === String(hashed || "").toLowerCase(); } catch (_) { return false; } } __name(verifyPassword2, "verifyPassword"); async function authMiddleware(context) { const { request, env } = context; const url = new URL(request.url); const publicPaths = ["/api/login", "/api/logout"]; if (publicPaths.includes(url.pathname)) { return null; } const JWT_TOKEN = env.JWT_TOKEN || env.JWT_SECRET || ""; const root = checkRootAdminOverride(request, JWT_TOKEN); if (root) { context.authPayload = root; return null; } const payload = await verifyJwtWithCache(JWT_TOKEN, request.headers.get("Cookie") || ""); if (!payload) { return new Response("Unauthorized", { status: 401 }); } context.authPayload = payload; return null; } __name(authMiddleware, "authMiddleware"); async function verifyJwtWithCache(JWT_TOKEN, cookieHeader) { const token = (cookieHeader.split(";").find((s) => s.trim().startsWith("iding-session=")) || "").split("=")[1] || ""; if (!globalThis.__JWT_CACHE__) globalThis.__JWT_CACHE__ = new Map(); const now = Date.now(); for (const [key, value] of globalThis.__JWT_CACHE__.entries()) { if (value.exp <= now) { globalThis.__JWT_CACHE__.delete(key); } } let payload = false; if (token && globalThis.__JWT_CACHE__.has(token)) { const cached = globalThis.__JWT_CACHE__.get(token); if (cached.exp > now) { payload = cached.payload; } else { globalThis.__JWT_CACHE__.delete(token); } } if (!payload) { payload = JWT_TOKEN ? await verifyJwt(JWT_TOKEN, cookieHeader) : false; if (token && payload) { globalThis.__JWT_CACHE__.set(token, { payload, exp: now + 30 * 60 * 1e3 }); } } return payload; } __name(verifyJwtWithCache, "verifyJwtWithCache"); function checkRootAdminOverride(request, JWT_TOKEN) { try { if (!JWT_TOKEN) return null; const auth = request.headers.get("Authorization") || request.headers.get("authorization") || ""; const xToken = request.headers.get("X-Admin-Token") || request.headers.get("x-admin-token") || ""; let urlToken = ""; try { const u = new URL(request.url); urlToken = u.searchParams.get("admin_token") || ""; } catch (_) { } const bearer = auth.startsWith("Bearer ") ? auth.slice(7).trim() : ""; if (bearer && bearer === JWT_TOKEN) return { role: "admin", username: "__root__", userId: 0 }; if (xToken && xToken === JWT_TOKEN) return { role: "admin", username: "__root__", userId: 0 }; if (urlToken && urlToken === JWT_TOKEN) return { role: "admin", username: "__root__", userId: 0 }; return null; } catch (_) { return null; } } __name(checkRootAdminOverride, "checkRootAdminOverride"); async function resolveAuthPayload(request, JWT_TOKEN) { const root = checkRootAdminOverride(request, JWT_TOKEN); if (root) return root; return await verifyJwtWithCache(JWT_TOKEN, request.headers.get("Cookie") || ""); } __name(resolveAuthPayload, "resolveAuthPayload"); function createRouter() { const router = new Router(); router.post("/api/login", async (context) => { const { request, env } = context; let DB; try { DB = await getDatabaseWithValidation(env); } catch (error) { console.error("\u767B\u5F55\u65F6\u6570\u636E\u5E93\u8FDE\u63A5\u5931\u8D25:", error.message); return new Response("\u6570\u636E\u5E93\u8FDE\u63A5\u5931\u8D25", { status: 500 }); } const ADMIN_NAME = String(env.ADMIN_NAME || "admin").trim().toLowerCase(); const ADMIN_PASSWORD = env.ADMIN_PASSWORD || env.ADMIN_PASS || ""; const GUEST_PASSWORD = env.GUEST_PASSWORD || ""; const JWT_TOKEN = env.JWT_TOKEN || env.JWT_SECRET || ""; try { const body = await request.json(); const name = String(body.username || "").trim().toLowerCase(); const password = String(body.password || "").trim(); if (!name || !password) { return new Response("\u7528\u6237\u540D\u6216\u5BC6\u7801\u4E0D\u80FD\u4E3A\u7A7A", { status: 400 }); } if (name === ADMIN_NAME && ADMIN_PASSWORD && password === ADMIN_PASSWORD) { let adminUserId = 0; try { const u = await DB.prepare("SELECT id FROM users WHERE username = ?").bind(ADMIN_NAME).all(); if (u?.results?.length) { adminUserId = Number(u.results[0].id); } else { await DB.prepare("INSERT INTO users (username, role, can_send, mailbox_limit) VALUES (?, 'admin', 1, 9999)").bind(ADMIN_NAME).run(); const again = await DB.prepare("SELECT id FROM users WHERE username = ?").bind(ADMIN_NAME).all(); adminUserId = Number(again?.results?.[0]?.id || 0); } } catch (_) { adminUserId = 0; } const token = await createJwt(JWT_TOKEN, { role: "admin", username: ADMIN_NAME, userId: adminUserId }); const headers = new Headers({ "Content-Type": "application/json" }); headers.set("Set-Cookie", buildSessionCookie(token, request.url)); return new Response(JSON.stringify({ success: true, role: "admin", can_send: 1, mailbox_limit: 9999 }), { headers }); } if (name === "guest" && GUEST_PASSWORD && password === GUEST_PASSWORD) { const token = await createJwt(JWT_TOKEN, { role: "guest", username: "guest" }); const headers = new Headers({ "Content-Type": "application/json" }); headers.set("Set-Cookie", buildSessionCookie(token, request.url)); return new Response(JSON.stringify({ success: true, role: "guest" }), { headers }); } try { const { results } = await DB.prepare("SELECT id, password_hash, role, mailbox_limit, can_send FROM users WHERE username = ?").bind(name).all(); if (results && results.length) { const row = results[0]; const ok = await verifyPassword2(password, row.password_hash || ""); if (ok) { const role = row.role === "admin" ? "admin" : "user"; const token = await createJwt(JWT_TOKEN, { role, username: name, userId: row.id }); const headers = new Headers({ "Content-Type": "application/json" }); headers.set("Set-Cookie", buildSessionCookie(token, request.url)); const canSend = role === "admin" ? 1 : row.can_send ? 1 : 0; const mailboxLimit = role === "admin" ? row.mailbox_limit || 20 : row.mailbox_limit || 10; return new Response(JSON.stringify({ success: true, role, can_send: canSend, mailbox_limit: mailboxLimit }), { headers }); } } } catch (_) { } try { const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/; if (emailRegex.test(name)) { const mailboxInfo = await verifyMailboxLogin(name, password, DB); if (mailboxInfo) { const token = await createJwt(JWT_TOKEN, { role: "mailbox", username: name, mailboxId: mailboxInfo.id, mailboxAddress: mailboxInfo.address }); const headers = new Headers({ "Content-Type": "application/json" }); headers.set("Set-Cookie", buildSessionCookie(token, request.url)); return new Response(JSON.stringify({ success: true, role: "mailbox", mailbox: mailboxInfo.address, can_send: 0, mailbox_limit: 1 }), { headers }); } } } catch (_) { } return new Response("\u7528\u6237\u540D\u6216\u5BC6\u7801\u9519\u8BEF", { status: 401 }); } catch (_) { return new Response("Bad Request", { status: 400 }); } }); router.post("/api/logout", async (context) => { const { request } = context; const headers = new Headers({ "Content-Type": "application/json" }); try { const u = new URL(request.url); const isHttps = u.protocol === "https:"; const secureFlag = isHttps ? " Secure;" : ""; headers.set("Set-Cookie", `iding-session=; HttpOnly;${secureFlag} Path=/; SameSite=Strict; Max-Age=0`); } catch (_) { headers.set("Set-Cookie", "iding-session=; HttpOnly; Path=/; SameSite=Strict; Max-Age=0"); } return new Response(JSON.stringify({ success: true }), { headers }); }); router.get("/api/session", async (context) => { const { request, env, authPayload } = context; const ADMIN_NAME = String(env.ADMIN_NAME || "admin").trim().toLowerCase(); if (!authPayload) { return new Response("Unauthorized", { status: 401 }); } const strictAdmin = authPayload.role === "admin" && (String(authPayload.username || "").trim().toLowerCase() === ADMIN_NAME || String(authPayload.username || "") === "__root__"); return Response.json({ authenticated: true, role: authPayload.role || "admin", username: authPayload.username || "", strictAdmin }); }); router.get("/api new Set([ "/", "/index.html", "/login", "/login.html", "/admin.html", "/html/mailboxes.html", "/mailboxes.html", "/mailbox.html", "/html/mailbox.html", "/templates/app.html", "/templates/footer.html", "/templates/loading.html", "/templates/loading-inline.html", "/templates/toast.html", "/app.js", "/app.css", "/admin.js", "/admin.css", "/login.js", "/login.css", "/mailbox.js", "/mock.js", "/favicon.svg", "/route-guard.js", "/app-router.js", "/app-mobile.js", "/app-mobile.css", "/mailbox.css", "/auth-guard.js", "/storage.js" ]); this.allowedPrefixes = [ "/assets/", "/pic/", "/templates/", "/public/", "/js/", "/css/", "/html/" ]; this.protectedPaths = new Set([ "/admin.html", "/admin", "/admin/", "/mailboxes.html", "/html/mailboxes.html", "/mailbox.html", "/mailbox", "/mailbox/" ]); this.guestOnlyPaths = new Set([ "/login", "/login.html" ]); } isPathAllowed(pathname) { if (this.allowedPaths.has(pathname)) { return true; } return this.allowedPrefixes.some((prefix) => pathname.startsWith(prefix)); } isProtectedPath(pathname) { return this.protectedPaths.has(pathname); } isGuestOnlyPath(pathname) { return this.guestOnlyPaths.has(pathname); } async handleAssetRequest(request, env, mailDomains) { const url = new URL(request.url); const pathname = url.pathname; const JWT_TOKEN = env.JWT_TOKEN || env.JWT_SECRET || ""; if (!this.isPathAllowed(pathname)) { return await this.handleIllegalPath(request, env, JWT_TOKEN); } if (this.isProtectedPath(pathname)) { const authResult = await this.checkProtectedPathAuth(request, JWT_TOKEN, url); if (authResult) return authResult; } if (this.isGuestOnlyPath(pathname)) { const guestResult = await this.checkGuestOnlyPath(request, JWT_TOKEN, url); if (guestResult) return guestResult; } if (!env.ASSETS || !env.ASSETS.fetch) { return Response.redirect(new URL("/login.html", url).toString(), 302); } const mappedRequest = this.handlePathMapping(request, url); if (pathname === "/" || pathname === "/index.html") { return await this.handleIndexPage(mappedRequest, env, mailDomains, JWT_TOKEN); } if (pathname === "/admin.html") { return await this.handleAdminPage(mappedRequest, env, JWT_TOKEN); } if (pathname === "/mailbox.html" || pathname === "/html/mailbox.html") { return await this.handleMailboxPage(mappedRequest, env, JWT_TOKEN); } if (pathname === "/mailboxes.html" || pathname === "/html/mailboxes.html") { return await this.handleAllMailboxesPage(mappedRequest, env, JWT_TOKEN); } return env.ASSETS.fetch(mappedRequest); } async handleIllegalPath(request, env, JWT_TOKEN) { const url = new URL(request.url); const payload = await resolveAuthPayload(request, JWT_TOKEN); if (payload !== false) { if (payload.role === "mailbox") { return Response.redirect(new URL("/html/mailbox.html", url).toString(), 302); } else { return Response.redirect(new URL("/", url).toString(), 302); } } return Response.redirect(new URL("/templates/loading.html", url).toString(), 302); } async checkProtectedPathAuth(request, JWT_TOKEN, url) { const payload = await resolveAuthPayload(request, JWT_TOKEN); if (!payload) { const loading = new URL("/templates/loading.html", url); if (url.pathname.includes("mailbox")) { loading.searchParams.set("redirect", "/html/mailbox.html"); } else { loading.searchParams.set("redirect", "/admin.html"); } return Response.redirect(loading.toString(), 302); } if (url.pathname.includes("mailbox")) { if (payload.role !== "mailbox") { return Response.redirect(new URL("/", url).toString(), 302); } if (url.pathname === "/" || url.pathname === "/index.html") { return Response.redirect(new URL("/html/mailbox.html", url).toString(), 302); } } else { const isAllowed = payload.role === "admin" || payload.role === "guest" || payload.role === "mailbox"; if (!isAllowed) { return Response.redirect(new URL("/", url).toString(), 302); } } return null; } async checkGuestOnlyPath(request, JWT_TOKEN, url) { const payload = await resolveAuthPayload(request, JWT_TOKEN); if (payload !== false) { return Response.redirect(new URL("/", url).toString(), 302); } return null; } handlePathMapping(request, url) { let targetUrl = url.toString(); if (url.pathname === "/login") { targetUrl = new URL("/login.html", url).toString(); } if (url.pathname === "/admin") { targetUrl = new URL("/admin.html", url).toString(); } if (url.pathname === "/mailbox") { targetUrl = new URL("/html/mailbox.html", url).toString(); } if (url.pathname === "/mailbox.html") { targetUrl = new URL("/html/mailbox.html", url).toString(); } if (url.pathname === "/mailboxes.html") { targetUrl = new URL("/html/mailboxes.html", url).toString(); } return new Request(targetUrl, request); } async handleIndexPage(request, env, mailDomains, JWT_TOKEN) { const url = new URL(request.url); const payload = await resolveAuthPayload(request, JWT_TOKEN); if (payload && payload.role === "mailbox") { return Response.redirect(new URL("/html/mailbox.html", url).toString(), 302); } const resp = await env.ASSETS.fetch(request); try { const text = await resp.text(); const injected = text.replace( '<meta name="mail-domains" content="">', `<meta name="mail-domains" content="${mailDomains.join(",")}">` ); return new Response(injected, { headers: { "Content-Type": "text/html; charset=utf-8", "Cache-Control": "no-store, no-cache, must-revalidate, max-age=0" } }); } catch (_) { return resp; } } async handleAdminPage(request, env, JWT_TOKEN) { const url = new URL(request.url); const payload = await resolveAuthPayload(request, JWT_TOKEN); if (!payload) { const loadingReq = new Request( new URL("/templates/loading.html?redirect=%2Fadmin.html", url).toString(), request ); return env.ASSETS.fetch(loadingReq); } const isAllowed = payload.role === "admin" || payload.role === "guest" || payload.role === "mailbox"; if (!isAllowed) { return Response.redirect(new URL("/", url).toString(), 302); } return env.ASSETS.fetch(request); } async handleMailboxPage(request, env, JWT_TOKEN) { const url = new URL(request.url); const payload = await resolveAuthPayload(request, JWT_TOKEN); if (!payload) { const loadingReq = new Request( new URL("/templates/loading.html?redirect=%2Fhtml%2Fmailbox.html", url).toString(), request ); return env.ASSETS.fetch(loadingReq); } if (payload.role !== "mailbox") { if (payload.role === "admin" || payload.role === "guest") { return Response.redirect(new URL("/", url).toString(), 302); } else { return Response.redirect(new URL("/login.html", url).toString(), 302); } } return env.ASSETS.fetch(request); } async handleAllMailboxesPage(request, env, JWT_TOKEN) { const url = new URL(request.url); const payload = await resolveAuthPayload(request, JWT_TOKEN); if (!payload) { const loadingReq = new Request( new URL("/templates/loading.html?redirect=%2Fhtml%2Fmailboxes.html", url).toString(), request ); return env.ASSETS.fetch(loadingReq); } const isStrictAdmin = payload.role === "admin" && (payload.username === "__root__" || payload.username); const isGuest = payload.role === "guest"; if (!isStrictAdmin && !isGuest) { return Response.redirect(new URL("/", url).toString(), 302); } return env.ASSETS.fetch(request); } addAllowedPath(path) { this.allowedPaths.add(path); } addAllowedPrefix(prefix) { this.allowedPrefixes.push(prefix); } removeAllowedPath(path) { this.allowedPaths.delete(path); } isApiPath(pathname) { return pathname.startsWith("/api/") || pathname === "/receive"; } getAccessLog(request) { const url = new URL(request.url); return { timestamp: ( new Date()).toISOString(), method: request.method, path: url.pathname, userAgent: request.headers.get("User-Agent") || "", referer: request.headers.get("Referer") || "", ip: request.headers.get("CF-Connecting-IP") || request.headers.get("X-Forwarded-For") || request.headers.get("X-Real-IP") || "unknown" }; } }; function createAssetManager() { return new AssetManager(); } __name(createAssetManager, "createAssetManager"); var server_default = { async fetch(request, env, ctx) { const url = new URL(request.url); let DB; try { DB = await getDatabaseWithValidation(env); } catch (error) { console.error("\u6570\u636E\u5E93\u8FDE\u63A5\u5931\u8D25:", error.message); return new Response("\u6570\u636E\u5E93\u8FDE\u63A5\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u914D\u7F6E", { status: 500 }); } const MAIL_DOMAINS = (env.MAIL_DOMAIN || "temp.example.com").split(/[,\s]+/).map((d) => d.trim()).filter(Boolean); if (!globalThis.__DB_INITED__) { await initDatabase(DB); globalThis.__DB_INITED__ = true; } const router = createRouter(); router.use(authMiddleware); const routeResponse = await router.handle(request, { request, env, ctx }); if (routeResponse) { return routeResponse; } const assetManager = createAssetManager(); return await assetManager.handleAssetRequest(request, env, MAIL_DOMAINS); }, async email(message, env, ctx) { let DB; try { DB = await getDatabaseWithValidation(env); await initDatabase(DB); } catch (error) { console.error("\u90AE\u4EF6\u5904\u7406\u65F6\u6570\u636E\u5E93\u8FDE\u63A5\u5931\u8D25:", error.message); return; } try { const headers = message.headers; const toHeader = headers.get("to") || headers.get("To") || ""; const fromHeader = headers.get("from") || headers.get("From") || ""; const subject = headers.get("subject") || headers.get("Subject") || "(\u65E0\u4E3B\u9898)"; let envelopeTo = ""; try { const toValue = message.to; if (Array.isArray(toValue) && toValue.length > 0) { envelopeTo = typeof toValue[0] === "string" ? toValue[0] : toValue[0].address || ""; } else if (typeof toValue === "string") { envelopeTo = toValue; } } catch (_) { } const resolvedRecipient = (envelopeTo || toHeader || "").toString(); const resolvedRecipientAddr = extractEmail(resolvedRecipient); const localPart = (resolvedRecipientAddr.split("@")[0] || "").toLowerCase(); forwardByLocalPart(message, localPart, ctx, env); let textContent = ""; let htmlContent = ""; let rawBuffer = null; try { const resp = new Response(message.raw); rawBuffer = await resp.arrayBuffer(); const rawText = await new Response(rawBuffer).text(); const parsed = parseEmailBody(rawText); textContent = parsed.text || ""; htmlContent = parsed.html || ""; if (!textContent && !htmlContent) textContent = (rawText || "").slice(0, 1e5); } catch (_) { textContent = ""; htmlContent = ""; } const mailbox = extractEmail(resolvedRecipient || toHeader); const sender = extractEmail(fromHeader); const r2 = env.MAIL_EML; let objectKey = ""; try { const now = new Date(); const y = now.getUTCFullYear(); const m = String(now.getUTCMonth() + 1).padStart(2, "0"); const d = String(now.getUTCDate()).padStart(2, "0"); const hh = String(now.getUTCHours()).padStart(2, "0"); const mm = String(now.getUTCMinutes()).padStart(2, "0"); const ss = String(now.getUTCSeconds()).padStart(2, "0"); const keyId = globalThis.crypto?.randomUUID && crypto.randomUUID() || `${Date.now()}-${Math.random().toString(36).slice(2)}`; const safeMailbox = (mailbox || "unknown").toLowerCase().replace(/[^a-z0-9@._-]/g, "_"); objectKey = `${y}/${m}/${d}/${safeMailbox}/${hh}${mm}${ss}-${keyId}.eml`; if (r2 && rawBuffer) { await r2.put(objectKey, new Uint8Array(rawBuffer), { httpMetadata: { contentType: "message/rfc822" } }); } } catch (e) { console.error("R2 put failed:", e); } const preview = (() => { const plain = textContent && textContent.trim() ? textContent : (htmlContent || "").replace(/<[^>]+>/g, " ").replace(/\s+/g, " ").trim(); return String(plain || "").slice(0, 120); })(); let verificationCode = ""; try { verificationCode = extractVerificationCode({ subject, text: textContent, html: htmlContent }); } catch (_) { } const resMb = await DB.prepare("SELECT id FROM mailboxes WHERE address = ?").bind(mailbox.toLowerCase()).all(); let mailboxId; if (Array.isArray(resMb?.results) && resMb.results.length) { mailboxId = resMb.results[0].id; } else { const [localPart2, domain] = (mailbox || "").toLowerCase().split("@"); if (localPart2 && domain) { await DB.prepare("INSERT INTO mailboxes (address, local_part, domain, password_hash, last_accessed_at) VALUES (?, ?, ?, NULL, CURRENT_TIMESTAMP)").bind((mailbox || "").toLowerCase(), localPart2, domain).run(); const created = await DB.prepare("SELECT id FROM mailboxes WHERE address = ?").bind((mailbox || "").toLowerCase()).all(); mailboxId = created?.results?.[0]?.id; } } if (!mailboxId) throw new Error("\u65E0\u6CD5\u89E3\u6790\u6216\u521B\u5EFA mailbox \u8BB0\u5F55"); let toAddrs = ""; try { const toValue = message.to; if (Array.isArray(toValue)) { toAddrs = toValue.map((v) => typeof v === "string" ? v : v?.address || "").filter(Boolean).join(","); } else if (typeof toValue === "string") { toAddrs = toValue; } else { toAddrs = resolvedRecipient || toHeader || ""; } } catch (_) { toAddrs = resolvedRecipient || toHeader || ""; } await DB.prepare(` INSERT INTO messages (mailbox_id, sender, to_addrs, subject, verification_code, preview, r2_bucket, r2_object_key) VALUES (?, ?, ?, ?, ?, ?, ?, ?) `).bind( mailboxId, sender, String(toAddrs || ""), subject || "(\u65E0\u4E3B\u9898)", verificationCode || null, preview || null, "mail-eml", objectKey || "" ).run(); } catch (err) { console.error("Email event handling error:", err); } } }; export { server_default as default };